<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Scala | tkawachi Blog]]></title>
  <link href="http://tkawachi.github.io/blog/categories/scala/atom.xml" rel="self"/>
  <link href="http://tkawachi.github.io/"/>
  <updated>2013-11-17T19:13:00+09:00</updated>
  <id>http://tkawachi.github.io/</id>
  <author>
    <name><![CDATA[KAWACHI Takashi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Play framework 2.2.1 scala でユーザ登録]]></title>
    <link href="http://tkawachi.github.io/blog/2013/11/17/play-2-dot-2-scala-user-login/"/>
    <updated>2013-11-17T18:36:00+09:00</updated>
    <id>http://tkawachi.github.io/blog/2013/11/17/play-2-dot-2-scala-user-login</id>
    <content type="html"><![CDATA[<p>Play framework 2.x を触り始めていて、まず最初にユーザ登録とログインを
扱いたいと思った。
Rails であれば devise で、というところだが、Play ではどうなっているのだろう？</p>

<p>Sample としてついてくる zentask や、
「play scala ユーザ登録」でググって上の方に出てくる
<a href="http://akiomik.hatenablog.jp/entry/2013/02/07/211054">ペ</a>
<a href="http://how-to-use-playframework-20.readthedocs.org/en/latest/subdocs/initial_create_application.html">ー</a>
<a href="http://d.hatena.ne.jp/sy-2010/20110517/1305650450">ジ</a>
を見ると、いずれもパスワードを生で保存している。</p>

<p>パスワードは生で保存していると何かの拍子に痛い目に合うので、真似したくない。
きっと Rails の devise みたいに再利用できるコンポーネントがあるだろうから、
それを使いたい。</p>

<p>Google+ のコミュニティで訪ねてみたところ<a href="http://securesocial.ws/">SecureSocial</a> と
<a href="https://github.com/t2v/play2-auth">play2-auth</a>
を教えてもらった。
SecureSocial を試してみる。</p>

<!-- more -->


<p>Play は 2.2.1, Scala でやる。</p>

<p>プロジェクト作成。アプリ名はログインしたいだけだから <code>just-login</code> にする。</p>

<pre><code>$ play new just-login
</code></pre>

<p><a href="http://securesocial.ws/guide/installation.html">http://securesocial.ws/guide/installation.html</a> に従って進めていく。</p>

<p>project/Build.scala を追加。</p>

<pre><code>import sbt._
import Keys._

object ApplicationBuild extends Build {
    val appName         = "just-login"
    val appVersion      = "1.0-SNAPSHOT"

    val appDependencies = Seq(
        "securesocial" %% "securesocial" % "2.1.2"
    )
    val main = play.Project(appName, appVersion, appDependencies).settings(
        resolvers += Resolver.url("sbt-plugin-releases", new URL("http://repo.scala-sbt.org/scalasbt/sbt-plugin-releases/"))(Resolver.ivyStylePatterns)
    )
}
</code></pre>

<p>重複した情報になるので、 build.sbt からは <code>name</code> と <code>version</code> を削除した。</p>

<p>conf/route にルーティング追加。それっぽいエンドポイントが一式備わってて、それっぽい感じ。</p>

<pre><code># Login page
GET     /login                      securesocial.controllers.LoginPage.login
GET     /logout                     securesocial.controllers.LoginPage.logout

# User Registration and password handling 
GET     /signup                     securesocial.controllers.Registration.startSignUp
POST    /signup                     securesocial.controllers.Registration.handleStartSignUp
GET     /signup/:token              securesocial.controllers.Registration.signUp(token)
POST    /signup/:token              securesocial.controllers.Registration.handleSignUp(token)
GET     /reset                      securesocial.controllers.Registration.startResetPassword
POST    /reset                      securesocial.controllers.Registration.handleStartResetPassword
GET     /reset/:token               securesocial.controllers.Registration.resetPassword(token)
POST    /reset/:token               securesocial.controllers.Registration.handleResetPassword(token)
GET     /password                   securesocial.controllers.PasswordChange.page
POST    /password                   securesocial.controllers.PasswordChange.handlePasswordChange

# Providers entry points
GET     /authenticate/:provider     securesocial.controllers.ProviderController.authenticate(provider)
POST    /authenticate/:provider     securesocial.controllers.ProviderController.authenticateByPost(provider)
GET     /not-authorized             securesocial.controllers.ProviderController.notAuthorized
</code></pre>

<p>次に <code>conf/play.plugins</code> を作成し、以下の内容を記述。
ユーザ名とパスワードでログインしたいだけなので、
Twitter やら Facebook やらでログインするためのプラグインはざっくり削る。</p>

<pre><code>1500:com.typesafe.plugin.CommonsMailerPlugin
9994:securesocial.core.DefaultAuthenticatorStore
9995:securesocial.core.DefaultIdGenerator
9996:securesocial.core.providers.utils.DefaultPasswordValidator
9997:securesocial.controllers.DefaultTemplatesPlugin
9998:service.UserServiceImpl
9999:securesocial.core.providers.utils.BCryptPasswordHasher
10004:securesocial.core.providers.UsernamePasswordProvider
</code></pre>

<p><code>9998:service.UserServiceImpl</code> の行に書いた <code>service.UserServiceImpl</code> は
自分の環境に合わせて実装する必要がある。</p>

<p><a href="https://github.com/jaliss/securesocial/blob/master/samples/scala/demo/app/service/InMemoryUserService.scala">InMemoryUserService.scala</a>
の内容をコピってきて、パッケージ名を <code>service</code> に、クラス名を <code>UserServiceImpl</code> に
変えて、 <code>app/service/UserServiceImpl.scala</code> として保存する。</p>

<p><a href="http://securesocial.ws/guide/configuration.html">http://securesocial.ws/guide/configuration.html</a> にのっとって
<code>conf/application.conf</code> に <code>smtp</code> の設定と、 <code>include "securesocial.conf"</code> を書く。
<code>conf/securesocial.conf</code> は <code>Sample configuration</code> の内容を書く。
<code>assetsController=controllers.ReverseMyCustomAssetsController</code> は
Asset のコントローラを自前で作っているときだけ必要ぽいので、コメントアウトする。</p>

<p><a href="https://github.com/typesafehub/play-plugins/blob/master/mailer/src/main/scala/com/typesafe/plugin/MailerPlugin.scala">MailerPlugin のソース</a>
を眺めるとわかるように <code>smtp.mock = true</code> を設定しておけば実際のメールは送信されず、
コンソールにメールの内容が出力される。</p>

<pre><code>smtp {
    ... 他の設定
    mock = true
}
</code></pre>

<p>ここまでで、ユーザ登録とログイン、ログアウト、パスワード忘れが実現できた。
パスワードが生で保存されることはなく、<code>BCryptPasswordHasher</code> によって生成された hash が格納される。</p>

<p>UserService はメモリ上じゃなく、DBへ格納するように実装することになる。
その際は
<a href="https://github.com/jaliss/securesocial/pull/163/files">https://github.com/jaliss/securesocial/pull/163/files</a>
のコードが参考になりそうだった。</p>

<h2>まとめ</h2>

<ul>
<li><a href="http://securesocial.ws/">SecureSocial</a> を使えば Play 2.2 + scala でユーザ登録・ログイン・パスワード忘れが簡単に実現できる</li>
<li>Rails の devise のように DB の schema は出してくれないので、比べると少し面倒かな&hellip;</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[scala の for]]></title>
    <link href="http://tkawachi.github.io/blog/2013/10/14/scala-for/"/>
    <updated>2013-10-14T11:35:00+09:00</updated>
    <id>http://tkawachi.github.io/blog/2013/10/14/scala-for</id>
    <content type="html"><![CDATA[<p>C や Java と同じように Scala にも for がある。</p>

<p>昔の Java におけるfor 文は、C と同じように <code>for (初期化; 継続条件; カウンタ更新)</code> という形しかなかった。
Java 5.0 で導入された拡張for文（<code>for (型 変数: コレクション)</code>の形）では <code>java.lang.Iterable</code> を実装したオブジェクトならなんでも繰り返しができるようになった。
便利になったなあと思ったのを覚えてる（2004年の話）。</p>

<h2>文法</h2>

<p>Scala で C の for 的なものをやろうとすると</p>

<pre><code>// C では
for (int i = 0; i &lt; 10; i++) { … }
// Scala では
for (i &lt;- 0 until 10) { … }
</code></pre>

<p>となるので「 <code>for (i &lt;- 初期値 until 上限)</code> という固定形なんだー」と最初は思ったのだが、そうではなく <code>for (i &lt;- 初期値.until(上限))</code> であり <code>for (i &lt;- obj)</code> が for 式のパターンである。
ここで<code>初期値.until(上限)</code> は <code>Range</code> 型の値を返す。</p>

<!-- more -->


<p>Scala の言語仕様によると for 式は以下の文法をもつ。</p>

<pre><code>Expr1 ::= ‘for’ (‘(’ Enumerators ‘)’ | ‘{’ Enumerators ‘}’) {nl} [‘yield’] Expr
Enumerators ::= Generator {semi Enumerator}
Enumerator ::= Generator
                | Guard
                | ‘val’ Pattern1 ‘=’ Expr
Generator ::= Pattern1 ‘&lt;-’ Expr [Guard]
Guard ::= ‘if’ PostfixExpr
</code></pre>

<p><code>Enumerator</code> の最後のパターンで <code>‘val’ Pattern1 ‘=’ Expr</code> とあるが、この val は deprecated になったようだ。
（Scala の言語仕様は更新が追いついていないらしく、現時点の最新（2.10.3）の言語仕様書は現時点で存在しない。）</p>

<h2>for式関連メソッド</h2>

<p>Scala の for 式は <code>foreach()</code>, <code>map()</code>, <code>flapMap()</code>, <code>withFilter()</code> が実装されていればなんでも回せる。
全てが必要なわけではなく、用いられるパターンによって必要なメソッドが決まる。</p>

<p><code>foreach()</code> が必要なパターン。 <code>yield</code> なしの時。</p>

<pre><code>for (i &lt;- obj) { … }
// 書き換えると
obj.foreach { case i =&gt; … }
</code></pre>

<p><code>map()</code> が必要なパターン。
Generator がひとつだけで <code>yield</code> で値を返す時。</p>

<pre><code>for (i &lt;- obj) yield { … }
// 書き換えると
obj.map { case i =&gt; … }
</code></pre>

<p><code>flatMap()</code> が必要なパターン。
Generator が複数あり、<code>yield</code> で値を返す時。</p>

<pre><code>for (i &lt;- obj1; j &lt;- obj2) yield { … }
// 書き換えると
obj1.flatMap { case i =&gt; for (j &lt;- obj2) yield { … } }
// obj1 には flatMap が必要。obj2 には map が必要。
</code></pre>

<p><code>withFilter()</code> が必要なパターン。
Guard があるとき。</p>

<pre><code>for (i &lt;- obj1 if i &lt; 0) { … }
// 書き換えると
obj1.withFilter(i =&gt; i &lt; 0).foreach { case i =&gt; … }
</code></pre>

<p>こんな感じで書き換えできるので、本質的には for 式要らないんだと思う。
でも複数の generator を回す時とか、<code>foreach</code> や <code>map</code>, <code>flatMap</code> で書くとネストが深くなってしまうので、for文だとスッキリかけて嬉しいってのはある。</p>

<h2>繰り返し以外の文脈</h2>

<p>必要なメソッドさえ揃っていればいいので、繰り返し以外の文脈で用いることができる。</p>

<p>たとえば <code>scala.Option</code> はオプショナルな値を表す。
値があるかもしれないし無いかもしれないという文脈であり、Javaでいえば null を使いたく場面で使う型である。
<code>Option</code> では for 式に関連するメソッドが、値がある時には関数を実行し、そうでなければ何もせず値なしを結果とするという意味合いで定義されている。</p>

<pre><code>for (i &lt;- Some(1); j &lt;- Some(2)) yield i + j // Some(3)
for (i &lt;- Some(1); j &lt;- None) yield i + j    // None
</code></pre>

<p>上記のように「<code>Option</code> 型の値がいくつかあり、全ての値が存在している時に何かする」というのが for 文で実現できる。</p>

<p>他にも <code>scala.concurrent.Future</code> は将来的に得られる値を表現する型で、
for式関連のメソッドは値が得られた時に関数を実行するように定義されている。</p>

<pre><code>val f1: Future[Int] = …
val f2: Future[Int] = …
val f3: Future[Int] = for (v1 &lt;- f1; v2 &lt;- f2) yield v1 + v2
</code></pre>

<p>ここでは <code>f1</code>, <code>f2</code> の値が将来得られたら <code>v1 + v2</code> を計算するという、コールバックの登録的な意味合いを持っている。</p>

<p><a href="https://github.com/jsuereth/scala-arm">scala-arm</a> では、最後にリソースを開放するという意味合いを for 式関連メソッドに持たせることで、for 式の最後でのリソース解放を実現している。</p>

<h2>まとめ</h2>

<p><code>foreach</code>, <code>map</code>, <code>flatMap</code>, <code>withFilter</code> というメソッドの定義次第で for 式の使い道は無限大。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Scalaのimplicit]]></title>
    <link href="http://tkawachi.github.io/blog/2013/09/28/scala-implicit/"/>
    <updated>2013-09-28T22:16:00+09:00</updated>
    <id>http://tkawachi.github.io/blog/2013/09/28/scala-implicit</id>
    <content type="html"><![CDATA[<p>Scala の implicit のお勉強メモ。</p>

<h2>なぜ implicit を使いたくなるか？</h2>

<p>コード片を見ただけではわからなくなるので、暗黙的な記述はあまり使わない方がいいんじゃないかと個人的に思うのだけど。
それでも便利な使い道があるから使われているみたい。</p>

<p>今自分が知っているところで次のパターンがあるみたい。
他の便利な使い方もきっとあるんじゃなかろうか。</p>

<ul>
<li>既存のクラスを変更せずにメソッドを追加したいとき (pimp my library pattern)。 implicit な関数, implicit なクラスを使う。</li>
<li>型パラメータ情報を実行時に使いたいとき。implicit パラメータをつかう。</li>
<li>共通のインタフェースを持たないクラス群に、共通のインタフェースをあとづけするとき (CONCEPT pattern)。implicit パラメータをつかう。</li>
</ul>


<!-- more -->


<h3>pimp my library pattern</h3>

<p>既存クラスに対してメソッドをあと付けしたいときに使う。
既存クラスが自分のメンテナンスできる範囲で書き換えてOKならこのパターン使わなくていいと思う。
既存クラスがサードパーティライブラリから提供されている場合など、書き換えられない、書き換えるのが面倒ときに使う。</p>

<p>やり方は 2.9 以前の場合は</p>

<ol>
<li>既存クラスをクラスのラッパークラスを定義する</li>
<li>既存クラスからラッパークラスへの暗黙的変換関数を定義する(implicit 関数)</li>
</ol>


<p>(pimp my library pattern)で、2.10 以降の場合は <a href="http://docs.scala-lang.org/overviews/core/implicit-classes.html">implicit class</a> が導入されたのでこれを使うんだと思う。</p>

<p>ここでは <code>Int</code> 型に関数 <code>f1</code> をあと付けしたいとする。</p>

<h4>pimp my libarary pattern</h4>

<p>pimp my library pattern ではまずラッパークラスを定義して、</p>

<pre><code>class MyRichInt(x: Int) {
    def f1 = …
}
</code></pre>

<p>暗黙的変換関数を定義する。</p>

<pre><code>object MyRichInt {
    implicit def intToMyRichInt(x: Int) = new MyRichInt(x)
}
</code></pre>

<p>使う時は暗黙的変換関数を import すれば、メソッドが増えたように感じる。</p>

<pre><code>import MyRichInt._
123.f1 // new MyRichInt(123).f1 相当
</code></pre>

<h4>Implicit class</h4>

<p>Implict class 2.10 から導入された機能。
pimy my library pattern が簡単に書けるようになった感じ。
こんな感じで定義。</p>

<pre><code>object Helpers {
    implicit class IntWithF(x: Int) {
        def f1 = …
    }
}
</code></pre>

<p>使う時は import する。
既存クラスに存在しないメンバを呼び出した場合に、暗黙的に変換できるクラスにメンバがあれば、コンパイラさんが変換→呼び出しという風にしてくれる。</p>

<pre><code>import Helpers._
123.f1 // new IntWithF(123).f1 相当
</code></pre>

<p>これでプログラマ的には既存の Int 型には無かったメンバ <code>f1</code> が増えたかのように扱える。</p>

<p>関連する項目として
<a href="http://docs.scala-lang.org/ja/overviews/core/value-classes.html">value class</a>
がある。
これを一緒に使えば暗黙変換するとき <code>new</code> されなくなる（メモリ割り当てされなくなる）ので
使えるときは使うのがいい。
頻繁に使われるものの場合は速くなりそう。</p>

<h3>型パラメータ情報を実行時に使いたいとき</h3>

<p>JVMは型パラメータをコンパイル時に消しちゃうので実行時には型パラメータの情報は使えない。
<code>def f[A] = new A // 間違い</code> とかしたいときに困る。</p>

<p>そんなときは最後の引き数リストに implicit な <code>ClassTag</code> を受け取るようにすればいいみたい。</p>

<pre><code>def f[A](implicit c: ClassTag[A]) = c.runtimeClass.newInstance().asInstanceOf[A]
</code></pre>

<p><code>c</code> 経由でインスタンスを作ったり出来る。
呼び出し時は <code>c</code> を渡す必要はない。
<code>f[Int]</code> などとして呼び出せる。</p>

<h3>CONCEPT pattern</h3>

<p>既存のクラス群が共通インタフェースを持ってたらひとつの関数で同じように処理できるのに、、ってときに使うパターン。
既存のクラスが書き換えられるなら、インタフェースを新規に作って実装しちゃってもいいんじゃないかと思わなくもないけど、アルゴリズムに関連する部分は分けておきたいなんてこともあるのかもしれない。</p>

<p>この共通インタフェースのことを concept っていうらしい。</p>

<p><code>Int</code> と <code>String</code> が両方共 <code>double</code> っていう関数を持っていたら、ステキなアルゴリズム（関数）がかけるのになあ、とする。</p>

<pre><code>trait DoubleConcept[A] {
    // 共通インタフェース
    def double(v: A): A
}
implicit val doubleInt = new DoubleCondept[Int] {
    // Int の double 定義
    def double(v: Int) = v * 2
}
implicit val doubleString = new DoubleConcept[String] {
    // String の double 定義
    def double(v: String) = v + v
}

def suteki[A](v: A)(implicit c: DoubleCondept[A]) = … // c.double(v) を使ったステキアルゴリズム

suteki(123) // suteki(123)(doubleInt) 相当
suteki("ABC") // suteki(ABC)(doubleString) 相当
</code></pre>

<p>型ごとの共通インタフェース実装を implicit val として定義しておいて、 implicit なパラメータリストでそれを暗黙的に渡す。
暗黙的過ぎて難しい。</p>

<p>ともあれ <code>suteki</code> 関数のなかでは <code>Int</code> と <code>String</code> が両方共 <code>double</code> という共通操作を持っているという前提で関数がかける。
<code>suteki</code>関数呼び出し時の <code>v</code> 引き数の型により、<code>c</code> が <code>doubleInt</code> なのか <code>doubleString</code> なのかはコンパイラが選択してくれる。</p>

<h2>雑感</h2>

<p>Scala の implicit は黒魔術。
使いたくなるパターンは多くなさそうなので用途を抑えておけば理解しやすい。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[テストデータのセットアップに trait を使う]]></title>
    <link href="http://tkawachi.github.io/blog/2013/09/23/use-trait-to-setup-test-data/"/>
    <updated>2013-09-23T23:59:00+09:00</updated>
    <id>http://tkawachi.github.io/blog/2013/09/23/use-trait-to-setup-test-data</id>
    <content type="html"><![CDATA[<p>9月半ばから始まった
<a href="https://www.coursera.org/course/progfun">Functional Programming Principles in Scala</a>
を受講している。
課題内のテストの書き方でこうやるのか、というところがあったのでメモ。</p>

<p>テストケース間でデータを共有したいときがある。
たとえば以下の例では <code>data1</code> と <code>data2</code> が共通なので共通化したくなる。</p>

<pre><code>class FooSuite extends FunSuite {
    test("test A") {
        val data1 = new FooData(…)
        val data2 = new FooData(…)
        // tests with data1 and data2
    }

    test("test B") {
        val data1 = new FooData(…)
        val data2 = new FooData(…)
        // another tests with data1 and data2
    }
}
</code></pre>

<p>普通は以下のようにメンバ変数にしたくなると思う。</p>

<pre><code>class FooSuite extends FunSuite {
    val data1 = new FooData(…)
    val data2 = new FooData(…)

    test("test A") {
        // tests with data1 and data2
    }

    test("test B") {
        // another tests with data1 and data2
    }
}
</code></pre>

<p>この方法は少し問題がある。</p>

<ul>
<li><code>new FooData(…)</code> が例外を出した場合に、<code>FooSuite</code> のインスタンス化に失敗するという問題がある</li>
<li><code>FooData</code> が mutable な場合に、前に実行したテストの内容により結果が変わる可能性がある</li>
</ul>


<p>課題のテストケースでは trait を使って以下のようにしていた。</p>

<pre><code>class FooSuite extends FunSuite {
    trait TestData {
        val data1 = new FooData(…)
        val data2 = new FooData(…)
    }

    test("test A") {
        new TestData {
            // tests with data1 and data2
        }
    }

    test("test B") {
        new TestData {
            // another tests with data1 and data2
        }
    }
}
</code></pre>

<p>各テスト内で <code>TestData</code> trait を継承した無名クラスを作り、無名クラスのコンストラクタ内でテストを実行する。
こうすることで <code>new FooData(…)</code> の実行はテスト実行時になり、各テストごとにデータが初期化されるので、上にあげた問題が解消する。</p>

<p><a href="http://www.scalatest.org/user_guide/sharing_fixtures">Sharing fixtures</a> をみると他の方法もいろいろある。
一番上にある Calling get-fixture methods が一番単純ぽい。
この方法で例を書き換えるとこうなる。</p>

<pre><code>class FooSuite extends FunSuite {
    def fixture = new {
        val data1 = new FooData(…)
        val data2 = new FooData(…)
    }

    test("test A") {
        val f = fixture
        // tests with f.data1 and f.data2
    }

    test("test B") {
        val f = fixture
        import f._
        // another tests with data1 and data2
    }
}
</code></pre>

<p>無名クラスのメンバとしてテストデータを作る。
こっちのほうがインデント少なくていいかも。
<code>import f._</code> すれば <code>f.</code> prefix 要らないしね。
<code>new</code> のあとクラス名無くてもコンパイル通るんだ… 知らなかったよ。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[sbt build definition]]></title>
    <link href="http://tkawachi.github.io/blog/2013/09/16/sbt-build-definition/"/>
    <updated>2013-09-16T22:17:00+09:00</updated>
    <id>http://tkawachi.github.io/blog/2013/09/16/sbt-build-definition</id>
    <content type="html"><![CDATA[<p><a href="http://scalajp.github.io/sbt-getting-started-guide-ja/">始める sbt</a>
を以前読んだときは
<a href="http://scalajp.github.io/sbt-getting-started-guide-ja/basic-def/">.sbt ビルド定義</a>
のところでぐっと難しくなってよくわからなくなった。
今日復習したのでメモ。</p>

<p>最初にまとめ。</p>

<ul>
<li><code>key := value</code> は新しい設定項目を追加する関数のようなもの(<code>Setting[T]</code>)を定義する。</li>
<li><code>Setting[T]</code> の入力は変更されない。</li>
<li><code>.sbt</code> を読み込むと <code>Setting[T]</code> のリストができる。<code>Setting[T]</code> のリストは、依存関係を考慮してソートされた後に適用される。</li>
<li><code>.sbt</code> の空行で区切られた塊は Scala の式。文ではないので <code>val</code>, <code>object</code>, <code>class</code> などは書けない。</li>
<li><code>key := value</code> は <code>key.:=(value)</code> といったメソッド呼び出しを別の書き方にしたもの。</li>
<li>sbtデフォルトの設定項目は
<a href="https://github.com/sbt/sbt/blob/0.13/main/src/main/scala/sbt/Keys.scala"><code>sbt.Keys</code></a>
に定義されている。</li>
<li><code>TaskKey[T]</code> は毎回計算されるキー。</li>
<li>sbtコンソールでアクセスするときは <code>SettingKey[T]</code>, <code>TaskKey[T]</code> などを呼び出す際の第一引き数文字列を使う。</li>
<li>キーの詳細はsbtコンソールから <code>inspect</code> で確認できる。</li>
</ul>


<!-- more -->


<p><code>Setting[T]</code> は、設定を入力に与えると、新しいキーと値のペアを追加したり、既存のキーを新しい値で追加したりといった変換を表す。
変換っていうのは、なにかを入力されたら、それを変更した結果を返すということで、関数みたいな概念で捉えればいいのだろう。
<code>Setting[T]</code>は関数型の精神に則り、入力値は変更しない。</p>

<p><code>.sbt</code> ファイル中の <code>key := value</code> は変換(<code>Setting[T]</code>)を定義している。
たとえば <code>name := "hello"</code> とあれば、キーが<code>name</code>で値が<code>"hello"</code>のペアを追加・上書きする変換を定義する。
<code>T</code> は設定値の型なので、この場合は <code>Setting[String]</code> が定義されたことになる。</p>

<p><code>.sbt</code> ファイルには変換が沢山含まれているので、結果として変換(<code>Setting[T]</code>)のリストができる。</p>

<p><code>Setting[T]</code> のリストに、sbt のデフォルトの設定を入力すると、<code>.sbt</code>ファイルが反映された設定が得られる。
<code>Setting[T]</code>が入力値を変更しないのでsbtのデフォルトの設定は変更されない。</p>

<p><code>.sbt</code> ファイルで <code>name := "hello"</code> と書いたら、<code>name.:=("hello")</code> のこと。
<code>key</code> の型は <code>SettingKey[String]</code> で、 <code>:=</code> は <code>String</code> を引数にとり <code>Setting[String]</code> を返す。
間違った型の値を代入しようとした場合には(例：<code>name := 1</code>)、型チェックでエラーになる。</p>

<p><code>:=</code> メソッドの他にも <code>+=</code> （リストへの要素追加）などがある。</p>

<p>sbtに用意されている設定項目（キー）は
<a href="https://github.com/sbt/sbt/blob/0.13/main/src/main/scala/sbt/Keys.scala"><code>sbt.Keys</code></a>
object に <code>SettingKey[T]</code> 型で定義されている。
<code>.sbt</code>ファイルの内容が評価される時は <code>import sbt.Keys._</code> された状態なので、 <code>sbt.Keys._</code> はパッケージ修飾なしに参照できる。
<a href="https://github.com/sbt/sbt/blob/0.13/main/src/main/scala/sbt/Keys.scala"><code>sbt.Keys</code></a>
は重要。
設定項目を探すときにちょくちょく参照することになる気がする。</p>

<p>たとえば <code>name</code> はこんな感じ。</p>

<pre><code>val name = SettingKey[String]("name", "Project name.", APlusSetting)
</code></pre>

<p>前述のように<code>SettingKey[String]</code>であることがわかる。</p>

<p><a href="https://github.com/sbt/sbt/blob/0.13/main/src/main/scala/sbt/Keys.scala"><code>sbt.Keys</code></a>
には <code>SettingKey[T]</code> 型以外にも、 <code>TaskKey[T]</code>, <code>InputKey[T]</code>, <code>AttributeKey[T]</code> 型の値が定義されてる。
<code>compile</code> のように sbt コンソールから入力するたびに実行してくれないと困るものは
<code>TaskKey[T]</code> として定義されている。
たとえば <code>compile</code> はこんな感じ。</p>

<pre><code>val compile = TaskKey[Analysis]("compile", "Compiles sources.", APlusTask)
</code></pre>

<p><code>SettingKey[T]</code>は一度計算されると結果が保持される。
<code>TaskKey[T]</code>は毎回計算される。
<code>SettingKey[T]</code>は<code>TaskKey[T]</code>に依存できない。</p>

<p><code>InputKey[T]</code>, <code>AttributeKey[T]</code> はまだ知らない。</p>

<p>sbtコンソールから入力するのはキーコンストラクタの第一引き数の文字列。</p>

<pre><code>val scalacOptions = TaskKey[Seq[String]]("scalac-options", "Options for the Scala compiler.")
</code></pre>

<p>とあったら <code>scalac-options</code> がsbtコンソールから入力時に指定する文字列になる。
<code>sbt.Keys</code> に CamelCase で定義されたものは大体コンソール入力時には小文字、ハイフン区切りになっている。</p>

<p>キーに関する情報はsbtコンソールから <code>inspect キー名</code> で得られる。</p>

<p><code>.sbt</code> ファイルの先頭に <code>import</code> 文を複数行書ける。<code>import</code> 文の間は空行をあけなくていい。
他の <code>SettingKey[T]</code> を参照するときに使うのかな。</p>
]]></content>
  </entry>
  
</feed>
