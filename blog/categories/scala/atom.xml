<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Scala | tkawachi Blog]]></title>
  <link href="http://tkawachi.github.io/blog/categories/scala/atom.xml" rel="self"/>
  <link href="http://tkawachi.github.io/"/>
  <updated>2013-09-29T00:06:13+09:00</updated>
  <id>http://tkawachi.github.io/</id>
  <author>
    <name><![CDATA[KAWACHI Takashi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Scalaのimplicit]]></title>
    <link href="http://tkawachi.github.io/blog/2013/09/28/scala-implicit/"/>
    <updated>2013-09-28T22:16:00+09:00</updated>
    <id>http://tkawachi.github.io/blog/2013/09/28/scala-implicit</id>
    <content type="html"><![CDATA[<p>Scala の implicit のお勉強メモ。</p>

<h2>なぜ implicit を使いたくなるか？</h2>

<p>コード片を見ただけではわからなくなるので、暗黙的な記述はあまり使わない方がいいんじゃないかと個人的に思うのだけど。
それでも便利な使い道があるから使われているみたい。</p>

<p>今自分が知っているところで次のパターンがあるみたい。
他の便利な使い方もきっとあるんじゃなかろうか。</p>

<ul>
<li>既存のクラスを変更せずにメソッドを追加したいとき (pimp my library pattern)。 implicit な関数, implicit なクラスを使う。</li>
<li>型パラメータ情報を実行時に使いたいとき。implicit パラメータをつかう。</li>
<li>共通のインタフェースを持たないクラス群に、共通のインタフェースをあとづけするとき (CONCEPT pattern)。implicit パラメータをつかう。</li>
</ul>


<!-- more -->


<h3>pimp my library pattern</h3>

<p>既存クラスに対してメソッドをあと付けしたいときに使う。
既存クラスが自分のメンテナンスできる範囲で書き換えてOKならこのパターン使わなくていいと思う。
既存クラスがサードパーティライブラリから提供されている場合など、書き換えられない、書き換えるのが面倒ときに使う。</p>

<p>やり方は 2.9 以前の場合は</p>

<ol>
<li>既存クラスをクラスのラッパークラスを定義する</li>
<li>既存クラスからラッパークラスへの暗黙的変換関数を定義する(implicit 関数)</li>
</ol>


<p>(pimp my library pattern)で、2.10 以降の場合は <a href="http://docs.scala-lang.org/overviews/core/implicit-classes.html">implicit class</a> が導入されたのでこれを使うんだと思う。</p>

<p>ここでは <code>Int</code> 型に関数 <code>f1</code> をあと付けしたいとする。</p>

<h4>pimp my libarary pattern</h4>

<p>pimp my library pattern ではまずラッパークラスを定義して、</p>

<pre><code>class MyRichInt(x: Int) {
    def f1 = …
}
</code></pre>

<p>暗黙的変換関数を定義する。</p>

<pre><code>object MyRichInt {
    implicit def intToMyRichInt(x: Int) = new MyRichInt(x)
}
</code></pre>

<p>使う時は暗黙的変換関数を import すれば、メソッドが増えたように感じる。</p>

<pre><code>import MyRichInt._
123.f1 // new MyRichInt(123).f1 相当
</code></pre>

<h4>Implicit class</h4>

<p>Implict class 2.10 から導入された機能。
pimy my library pattern が簡単に書けるようになった感じ。
こんな感じで定義。</p>

<pre><code>object Helpers {
    implicit class IntWithF(x: Int) {
        def f1 = …
    }
}
</code></pre>

<p>使う時は import する。
既存クラスに存在しないメンバを呼び出した場合に、暗黙的に変換できるクラスにメンバがあれば、コンパイラさんが変換→呼び出しという風にしてくれる。</p>

<pre><code>import Helpers._
123.f1 // new IntWithF(123).f1 相当
</code></pre>

<p>これでプログラマ的には既存の Int 型には無かったメンバ <code>f1</code> が増えたかのように扱える。</p>

<p>関連する項目として
<a href="http://docs.scala-lang.org/ja/overviews/core/value-classes.html">value class</a>
がある。
これを一緒に使えば暗黙変換するとき <code>new</code> されなくなる（メモリ割り当てされなくなる）ので
使えるときは使うのがいい。
頻繁に使われるものの場合は速くなりそう。</p>

<h3>型パラメータ情報を実行時に使いたいとき</h3>

<p>JVMは型パラメータをコンパイル時に消しちゃうので実行時には型パラメータの情報は使えない。
<code>def f[A] = new A // 間違い</code> とかしたいときに困る。</p>

<p>そんなときは最後の引き数リストに implicit な <code>ClassTag</code> を受け取るようにすればいいみたい。</p>

<pre><code>def f[A](implicit c: ClassTag[A]) = c.runtimeClass.newInstance().asInstanceOf[A]
</code></pre>

<p><code>c</code> 経由でインスタンスを作ったり出来る。
呼び出し時は <code>c</code> を渡す必要はない。
<code>f[Int]</code> などとして呼び出せる。</p>

<h3>CONCEPT pattern</h3>

<p>既存のクラス群が共通インタフェースを持ってたらひとつの関数で同じように処理できるのに、、ってときに使うパターン。
既存のクラスが書き換えられるなら、インタフェースを新規に作って実装しちゃってもいいんじゃないかと思わなくもないけど、アルゴリズムに関連する部分は分けておきたいなんてこともあるのかもしれない。</p>

<p>この共通インタフェースのことを concept っていうらしい。</p>

<p><code>Int</code> と <code>String</code> が両方共 <code>double</code> っていう関数を持っていたら、ステキなアルゴリズム（関数）がかけるのになあ、とする。</p>

<pre><code>trait DoubleConcept[A] {
    // 共通インタフェース
    def double(v: A): A
}
implicit val doubleInt = new DoubleCondept[Int] {
    // Int の double 定義
    def double(v: Int) = v * 2
}
implicit val doubleString = new DoubleConcept[String] {
    // String の double 定義
    def double(v: String) = v + v
}

def suteki[A](v: A)(implicit c: DoubleCondept[A]) = … // c.double(v) を使ったステキアルゴリズム

suteki(123) // suteki(123)(doubleInt) 相当
suteki("ABC") // suteki(ABC)(doubleString) 相当
</code></pre>

<p>型ごとの共通インタフェース実装を implicit val として定義しておいて、 implicit なパラメータリストでそれを暗黙的に渡す。
暗黙的過ぎて難しい。</p>

<p>ともあれ <code>suteki</code> 関数のなかでは <code>Int</code> と <code>String</code> が両方共 <code>double</code> という共通操作を持っているという前提で関数がかける。
<code>suteki</code>関数呼び出し時の <code>v</code> 引き数の型により、<code>c</code> が <code>doubleInt</code> なのか <code>doubleString</code> なのかはコンパイラが選択してくれる。</p>

<h2>雑感</h2>

<p>Scala の implicit は黒魔術。
使いたくなるパターンは多くなさそうなので用途を抑えておけば理解しやすい。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[テストデータのセットアップに trait を使う]]></title>
    <link href="http://tkawachi.github.io/blog/2013/09/23/use-trait-to-setup-test-data/"/>
    <updated>2013-09-23T23:59:00+09:00</updated>
    <id>http://tkawachi.github.io/blog/2013/09/23/use-trait-to-setup-test-data</id>
    <content type="html"><![CDATA[<p>9月半ばから始まった
<a href="https://www.coursera.org/course/progfun">Functional Programming Principles in Scala</a>
を受講している。
課題内のテストの書き方でこうやるのか、というところがあったのでメモ。</p>

<p>テストケース間でデータを共有したいときがある。
たとえば以下の例では <code>data1</code> と <code>data2</code> が共通なので共通化したくなる。</p>

<pre><code>class FooSuite extends FunSuite {
    test("test A") {
        val data1 = new FooData(…)
        val data2 = new FooData(…)
        // tests with data1 and data2
    }

    test("test B") {
        val data1 = new FooData(…)
        val data2 = new FooData(…)
        // another tests with data1 and data2
    }
}
</code></pre>

<p>普通は以下のようにメンバ変数にしたくなると思う。</p>

<pre><code>class FooSuite extends FunSuite {
    val data1 = new FooData(…)
    val data2 = new FooData(…)

    test("test A") {
        // tests with data1 and data2
    }

    test("test B") {
        // another tests with data1 and data2
    }
}
</code></pre>

<p>この方法は少し問題がある。</p>

<ul>
<li><code>new FooData(…)</code> が例外を出した場合に、<code>FooSuite</code> のインスタンス化に失敗するという問題がある</li>
<li><code>FooData</code> が mutable な場合に、前に実行したテストの内容により結果が変わる可能性がある</li>
</ul>


<p>課題のテストケースでは trait を使って以下のようにしていた。</p>

<pre><code>class FooSuite extends FunSuite {
    trait TestData {
        val data1 = new FooData(…)
        val data2 = new FooData(…)
    }

    test("test A") {
        new TestData {
            // tests with data1 and data2
        }
    }

    test("test B") {
        new TestData {
            // another tests with data1 and data2
        }
    }
}
</code></pre>

<p>各テスト内で <code>TestData</code> trait を継承した無名クラスを作り、無名クラスのコンストラクタ内でテストを実行する。
こうすることで <code>new FooData(…)</code> の実行はテスト実行時になり、各テストごとにデータが初期化されるので、上にあげた問題が解消する。</p>

<p><a href="http://www.scalatest.org/user_guide/sharing_fixtures">Sharing fixtures</a> をみると他の方法もいろいろある。
一番上にある Calling get-fixture methods が一番単純ぽい。
この方法で例を書き換えるとこうなる。</p>

<pre><code>class FooSuite extends FunSuite {
    def fixture = new {
        val data1 = new FooData(…)
        val data2 = new FooData(…)
    }

    test("test A") {
        val f = fixture
        // tests with f.data1 and f.data2
    }

    test("test B") {
        val f = fixture
        import f._
        // another tests with data1 and data2
    }
}
</code></pre>

<p>無名クラスのメンバとしてテストデータを作る。
こっちのほうがインデント少なくていいかも。
<code>import f._</code> すれば <code>f.</code> prefix 要らないしね。
<code>new</code> のあとクラス名無くてもコンパイル通るんだ… 知らなかったよ。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[sbt build definition]]></title>
    <link href="http://tkawachi.github.io/blog/2013/09/16/sbt-build-definition/"/>
    <updated>2013-09-16T22:17:00+09:00</updated>
    <id>http://tkawachi.github.io/blog/2013/09/16/sbt-build-definition</id>
    <content type="html"><![CDATA[<p><a href="http://scalajp.github.io/sbt-getting-started-guide-ja/">始める sbt</a>
を以前読んだときは
<a href="http://scalajp.github.io/sbt-getting-started-guide-ja/basic-def/">.sbt ビルド定義</a>
のところでぐっと難しくなってよくわからなくなった。
今日復習したのでメモ。</p>

<p>最初にまとめ。</p>

<ul>
<li><code>key := value</code> は新しい設定項目を追加する関数のようなもの(<code>Setting[T]</code>)を定義する。</li>
<li><code>Setting[T]</code> の入力は変更されない。</li>
<li><code>.sbt</code> を読み込むと <code>Setting[T]</code> のリストができる。<code>Setting[T]</code> のリストは、依存関係を考慮してソートされた後に適用される。</li>
<li><code>.sbt</code> の空行で区切られた塊は Scala の式。文ではないので <code>val</code>, <code>object</code>, <code>class</code> などは書けない。</li>
<li><code>key := value</code> は <code>key.:=(value)</code> といったメソッド呼び出しを別の書き方にしたもの。</li>
<li>sbtデフォルトの設定項目は
<a href="https://github.com/sbt/sbt/blob/0.13/main/src/main/scala/sbt/Keys.scala"><code>sbt.Keys</code></a>
に定義されている。</li>
<li><code>TaskKey[T]</code> は毎回計算されるキー。</li>
<li>sbtコンソールでアクセスするときは <code>SettingKey[T]</code>, <code>TaskKey[T]</code> などを呼び出す際の第一引き数文字列を使う。</li>
<li>キーの詳細はsbtコンソールから <code>inspect</code> で確認できる。</li>
</ul>


<!-- more -->


<p><code>Setting[T]</code> は、設定を入力に与えると、新しいキーと値のペアを追加したり、既存のキーを新しい値で追加したりといった変換を表す。
変換っていうのは、なにかを入力されたら、それを変更した結果を返すということで、関数みたいな概念で捉えればいいのだろう。
<code>Setting[T]</code>は関数型の精神に則り、入力値は変更しない。</p>

<p><code>.sbt</code> ファイル中の <code>key := value</code> は変換(<code>Setting[T]</code>)を定義している。
たとえば <code>name := "hello"</code> とあれば、キーが<code>name</code>で値が<code>"hello"</code>のペアを追加・上書きする変換を定義する。
<code>T</code> は設定値の型なので、この場合は <code>Setting[String]</code> が定義されたことになる。</p>

<p><code>.sbt</code> ファイルには変換が沢山含まれているので、結果として変換(<code>Setting[T]</code>)のリストができる。</p>

<p><code>Setting[T]</code> のリストに、sbt のデフォルトの設定を入力すると、<code>.sbt</code>ファイルが反映された設定が得られる。
<code>Setting[T]</code>が入力値を変更しないのでsbtのデフォルトの設定は変更されない。</p>

<p><code>.sbt</code> ファイルで <code>name := "hello"</code> と書いたら、<code>name.:=("hello")</code> のこと。
<code>key</code> の型は <code>SettingKey[String]</code> で、 <code>:=</code> は <code>String</code> を引数にとり <code>Setting[String]</code> を返す。
間違った型の値を代入しようとした場合には(例：<code>name := 1</code>)、型チェックでエラーになる。</p>

<p><code>:=</code> メソッドの他にも <code>+=</code> （リストへの要素追加）などがある。</p>

<p>sbtに用意されている設定項目（キー）は
<a href="https://github.com/sbt/sbt/blob/0.13/main/src/main/scala/sbt/Keys.scala"><code>sbt.Keys</code></a>
object に <code>SettingKey[T]</code> 型で定義されている。
<code>.sbt</code>ファイルの内容が評価される時は <code>import sbt.Keys._</code> された状態なので、 <code>sbt.Keys._</code> はパッケージ修飾なしに参照できる。
<a href="https://github.com/sbt/sbt/blob/0.13/main/src/main/scala/sbt/Keys.scala"><code>sbt.Keys</code></a>
は重要。
設定項目を探すときにちょくちょく参照することになる気がする。</p>

<p>たとえば <code>name</code> はこんな感じ。</p>

<pre><code>val name = SettingKey[String]("name", "Project name.", APlusSetting)
</code></pre>

<p>前述のように<code>SettingKey[String]</code>であることがわかる。</p>

<p><a href="https://github.com/sbt/sbt/blob/0.13/main/src/main/scala/sbt/Keys.scala"><code>sbt.Keys</code></a>
には <code>SettingKey[T]</code> 型以外にも、 <code>TaskKey[T]</code>, <code>InputKey[T]</code>, <code>AttributeKey[T]</code> 型の値が定義されてる。
<code>compile</code> のように sbt コンソールから入力するたびに実行してくれないと困るものは
<code>TaskKey[T]</code> として定義されている。
たとえば <code>compile</code> はこんな感じ。</p>

<pre><code>val compile = TaskKey[Analysis]("compile", "Compiles sources.", APlusTask)
</code></pre>

<p><code>SettingKey[T]</code>は一度計算されると結果が保持される。
<code>TaskKey[T]</code>は毎回計算される。
<code>SettingKey[T]</code>は<code>TaskKey[T]</code>に依存できない。</p>

<p><code>InputKey[T]</code>, <code>AttributeKey[T]</code> はまだ知らない。</p>

<p>sbtコンソールから入力するのはキーコンストラクタの第一引き数の文字列。</p>

<pre><code>val scalacOptions = TaskKey[Seq[String]]("scalac-options", "Options for the Scala compiler.")
</code></pre>

<p>とあったら <code>scalac-options</code> がsbtコンソールから入力時に指定する文字列になる。
<code>sbt.Keys</code> に CamelCase で定義されたものは大体コンソール入力時には小文字、ハイフン区切りになっている。</p>

<p>キーに関する情報はsbtコンソールから <code>inspect キー名</code> で得られる。</p>

<p><code>.sbt</code> ファイルの先頭に <code>import</code> 文を複数行書ける。<code>import</code> 文の間は空行をあけなくていい。
他の <code>SettingKey[T]</code> を参照するときに使うのかな。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[akka memo]]></title>
    <link href="http://tkawachi.github.io/blog/2013/09/15/akka-memo/"/>
    <updated>2013-09-15T21:30:00+09:00</updated>
    <id>http://tkawachi.github.io/blog/2013/09/15/akka-memo</id>
    <content type="html"><![CDATA[<p>Scala 2.10 から付いてくる Akka の Actor についてのお勉強メモ。
全然まとまっていないが晒しておく。</p>

<!-- more -->


<h2>概念</h2>

<h3>Actor</h3>

<p><code>akka.actor.Actor</code>。
メッセージを受けて処理をする人。</p>

<h3>Mailbox</h3>

<p>Actorへのメッセージが溜まるところ。</p>

<h3>Supervision</h3>

<p>Actor間の依存関係のこと。
Actorインスタンスはツリー構造になっている。
親が supervisor となる。</p>

<p>Actor が失敗したらどうするかは supervisor の actor が制御する。</p>

<p>親 actor が shutdown したら、その子どもは全て shutdown する。</p>

<p>タスクのまとまり毎にサブツリーを形成するようにすると良いらしい。</p>

<h3>Actor Path</h3>

<p>Actorインスタンスにはツリー構造上の位置を表す文字列がついており、これを actor path と呼ぶ。
<code>/</code>, <code>/user</code>, <code>/user/abc</code> など。</p>

<h3>ActorSystem</h3>

<p><code>akka.actor.ActorSystem</code>。
ツリー全体を管理するもの。
ActorSystemはスレッドを何本も使う重い構造なので沢山作りすぎない。</p>

<h3>Router</h3>

<p>Actor の一種。メッセージを受け取って他の actor に投げる(Routingする)。
投げられる側を routee と呼ぶ。
Routee は router の子どもになる。</p>

<p>以下の様な router が提供されている。どのようにルーティングするかは名前から大体想像がつく。
ロードバランサ的なやつですかね。</p>

<ul>
<li>akka.routing.RoundRobinRouter</li>
<li>akka.routing.RandomRouter</li>
<li>akka.routing.SmallestMailboxRouter</li>
<li>akka.routing.BroadcastRouter</li>
<li>akka.routing.ScatterGatherFirstCompletedRouter</li>
<li>akka.routing.ConsistentHashingRouter</li>
</ul>


<h3>Props</h3>

<p><code>akka.actor.Props</code>。
Actorをインスタンス化する際の設定。
Immutable なので複数の actor をインスタンス化する際に使いまわせる。</p>

<h2>ライフサイクル</h2>

<p>生まれてから死ぬまで。</p>

<p>停止信号を受け取ると以下の手順で止まる。</p>

<ol>
<li>mailbox メッセージの処理をやめる</li>
<li>子どもに停止信号を送る</li>
<li>全ての子どもから停止完了がくるのを待つ</li>
<li>自分自身の停止完了プロセスを実行

<ol>
<li><code>postStop()</code> を呼び出す</li>
<li>mailbox をダンプ</li>
<li><code>DeathWatch</code> に停止完了を知らせる</li>
<li>親に停止完了を知らせる</li>
</ol>
</li>
</ol>


<h3>止めかたのパターン</h3>

<ul>
<li>ActorSystem を shutdown() する。</li>
<li>PoisonPill を actor に送る。通常メッセージと同じように mailbox に送られ、処理されるときに actor が停止する。</li>
<li><code>context.stop(self)</code>, <code>context.stop(child)</code> で止める。</li>
</ul>


<h3>殺しかた</h3>

<ul>
<li>Kill を送ると即座に死ぬ</li>
</ul>


<h3>問題が起きたときの判断</h3>

<p>以下のいずれか。</p>

<ul>
<li>Resume</li>
<li>Restart</li>
<li>Terminate</li>
<li>Escalate</li>
</ul>


<h3>Restart</h3>

<ul>
<li>子どもをterminate。自分をterminate。</li>
<li>子どもの mailbox は保持される。 mailbox を破棄したい時は supervisor が terminate, recreate すること。</li>
</ul>


<h3>ストラテジー</h3>

<ul>
<li>one-for-one strategy &mdash; default

<ul>
<li>Restart (defaultDecider)</li>
</ul>
</li>
<li>all-for-one strategy</li>
</ul>


<p><a href="http://doc.akka.io/docs/akka/snapshot/general/supervision.html#supervision-restart">What Restarting Means</a></p>

<p>失敗は３つのカテゴリに分けられる。</p>

<ul>
<li>特定のメッセージを処理する際のプログラムエラー</li>
<li>メッセージを処理する際に使われる外部リソースの一時的なエラー</li>
<li>Actorの内部状態が壊れた</li>
</ul>


<p>内部状態が壊れたら内部状態を破棄しなければならない。Supervisorや他の子どもが壊れた内部状態の影響を受けなければ、restartするのがベスト。
Restartの際には内部的に新しい Actor がインスタンス化され、ActorRefの参照しているものが切り替わる。
ActorRef の存在意義のひとつは、この切り替え。</p>

<p>Actorが内部で作った子 Actor の ActorRef を外部に保持していると、
Actor restart 時に無効な参照になる。</p>

<p>ガーディアン直下の actor に対応する ActorRef は ActorSystem 終了時まで有効だろうと思う。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ScalaTestでMockito]]></title>
    <link href="http://tkawachi.github.io/blog/2013/08/26/mockito-scala/"/>
    <updated>2013-08-26T10:14:00+09:00</updated>
    <id>http://tkawachi.github.io/blog/2013/08/26/mockito-scala</id>
    <content type="html"><![CDATA[<p>ScalaTestでMockitoを使うためのお勉強ノート</p>

<h2>Setup</h2>

<p><code>build.sbt</code> に追加。</p>

<pre><code>libraryDependencies ++= Seq(
  "org.scalatest" %% "scalatest" % "1.9.1" % "test",
  "org.mockito" % "mockito-core" % "1.9.5" % "test"
)
</code></pre>

<p>テストで <code>MockitoSugar</code> を mixin し、以下の import 行を追加。</p>

<pre><code>import org.mockito.Matchers._
import org.mockito.Mockito._
</code></pre>

<h2>Mock作成</h2>

<pre><code>// ClassToMock のモックを作成
val m = mock[ClassToMock]
</code></pre>

<p>作ったモックはデフォルトで全メソッドコールに対して <code>null</code> を返す。
メソッドの戻り値として<code>null</code>ではなくモックを返したい時は次のようにする。</p>

<pre><code>// メソッド呼び出しでモックを返すモック
mock[ClassToMock](RETURNS_MOCKS)
// 返されたモックもモックを返すモック
mock[ClassToMock](RETURNS_DEEP_STUBS)
</code></pre>

<h2>引数に応じて戻り値を変える</h2>

<p><code>when(メソッド呼び出し).thenReturn(戻り値)</code> で登録する。
メソッド呼び出し部の引き数には <code>any</code> で任意の型の任意の値に、<code>anyString</code>, <code>anyBoolean</code>, <code>anyByte</code>, <code>anyChar</code>などで基本的な型の任意の値に <code>anyVararg</code> で任意の可変引き数にマッチさせることができる。</p>

<pre><code>// m.method1(何か) が呼ばれたら 10 を返す
when(m.method1(any)).thenReturn(10)
</code></pre>

<p>引数が２つ以上あり、いずれかで <code>any</code> などのマッチャーを使った場合には、他の引き数もマッチャーにする必要がある。
オブジェクトが等しいことを示すマッチャーは <code>eq(obj)</code> で作れる。</p>

<p>後から登録したものが先にマッチするので、条件のゆるいもの（マッチ範囲が広いもの）を先に書く。</p>

<h3>１回目、２回目で違う値を返す</h3>

<p><code>thenReturn()</code> の可変引き数版を使う</p>

<pre><code>// 最初は 10, 次は 20, それ以降はずっと 30 を返す
when(m.method1()).thenReturn(10, 20, 30)
</code></pre>

<h2>例外を起こす</h2>

<pre><code>// method1() が呼ばれたら例外を起こす
when(m.method1()).thenThrow(new RuntimeException("Gau gau"))
</code></pre>

<p><code>thenReturn</code> と同じように１回目、２回目で違う例外を起こすことも可能。
むしろ <code>thenReturn</code> と組み合わせることができる。</p>

<pre><code>when(m.method1())
  .thenReturn(10, 20) // １回目は10, ２回目は20を返す
  .thenThrow(new FooException, new BarException) // ３、４回目は例外
  .thenReturn(30) // ５回目以降は30を返す
</code></pre>

<h2>オブジェクトの一部をモックする(spy)</h2>

<p><code>mock[ClassToMock]</code> はフルのモック。一部だけモックしたい場合はこっち。<code>spy</code>と呼ぶ。</p>

<pre><code>// obj は普通のオブジェクト
val s = spy(obj)
// s.method1(何か) が呼ばれたら obj の実装を使わずに 10 を返す。
doReturn(10).when(s).method1(any[ClassOfArg])
</code></pre>

<p><code>thenReturn</code> が <code>doReturn</code> になって順番が代わり、メソッド呼び出しも <code>when</code> の外に出す。
<code>thenReturn</code>の書き方では実際のメソッドが呼ばれるので、呼ばれては困るときにこちらの書き方をする。</p>

<p>この記法の場合は <code>any</code> を使うときに型を指定しなければならなかった
（理由はわかってない）。</p>

<h2>メソッドが呼び出されたことを確認する(verify)</h2>

<p><code>when()</code>, <code>thenReturn()</code>, <code>doReturn()</code> などは関数呼び出しの前に用意する。
用意したものがテスト中で呼び出されなくても問題ない。</p>

<p>呼び出されたことを確認するには <code>verify()</code> を使う。</p>

<pre><code>// テストを実行
m.method1(123);
// method1() が何らかの整数引き数で呼び出されたことを確認
verify(m).method1(anyInt);
</code></pre>

<p>複数回呼び出されたことを確認するときは、<code>verify()</code>の第二引き数で回数指定をする。</p>

<pre><code>// 2回呼び出されたことを確認
verify(m, times(2)).method1(anyInt)
// 少なくとも2回
verify(m, atLeast(2)).method1(anyInt)
// 多くとも3回
verify(m, atMost(3)).method1(anyInt)
</code></pre>

<h3>呼び出されてないことを確認する</h3>

<p><code>never</code> を使う。</p>

<pre><code>// 一度も呼ばれてないことを確認
verify(m, never).method1(anyInt)
</code></pre>

<h2>より進んだ使い方</h2>

<p><a href="http://docs.mockito.googlecode.com/hg/latest/org/mockito/Mockito.html">Mockitoのドキュメント</a>
に書いてある。</p>
]]></content>
  </entry>
  
</feed>
