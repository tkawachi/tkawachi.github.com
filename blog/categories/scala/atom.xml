<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Scala | tkawachi Blog]]></title>
  <link href="http://tkawachi.github.io/blog/categories/scala/atom.xml" rel="self"/>
  <link href="http://tkawachi.github.io/"/>
  <updated>2013-09-24T00:50:56+09:00</updated>
  <id>http://tkawachi.github.io/</id>
  <author>
    <name><![CDATA[KAWACHI Takashi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[テストデータのセットアップに trait を使う]]></title>
    <link href="http://tkawachi.github.io/blog/2013/09/23/use-trait-to-setup-test-data/"/>
    <updated>2013-09-23T23:59:00+09:00</updated>
    <id>http://tkawachi.github.io/blog/2013/09/23/use-trait-to-setup-test-data</id>
    <content type="html"><![CDATA[<p>9月半ばから始まった
<a href="https://www.coursera.org/course/progfun">Functional Programming Principles in Scala</a>
を受講している。
課題内のテストの書き方でこうやるのか、というところがあったのでメモ。</p>

<p>テストケース間でデータを共有したいときがある。
たとえば以下の例では <code>data1</code> と <code>data2</code> が共通なので共通化したくなる。</p>

<pre><code>class FooSuite extends FunSuite {
    test("test A") {
        val data1 = new FooData(…)
        val data2 = new FooData(…)
        // tests with data1 and data2
    }

    test("test B") {
        val data1 = new FooData(…)
        val data2 = new FooData(…)
        // another tests with data1 and data2
    }
}
</code></pre>

<p>普通は以下のようにメンバ変数にしたくなると思う。</p>

<pre><code>class FooSuite extends FunSuite {
    val data1 = new FooData(…)
    val data2 = new FooData(…)

    test("test A") {
        // tests with data1 and data2
    }

    test("test B") {
        // another tests with data1 and data2
    }
}
</code></pre>

<p>この方法は少し問題がある。</p>

<ul>
<li><code>new FooData(…)</code> が例外を出した場合に、<code>FooSuite</code> のインスタンス化に失敗するという問題がある</li>
<li><code>FooData</code> が mutable な場合に、前に実行したテストの内容により結果が変わる可能性がある</li>
</ul>


<p>課題のテストケースでは trait を使って以下のようにしていた。</p>

<pre><code>class FooSuite extends FunSuite {
    trait TestData {
        val data1 = new FooData(…)
        val data2 = new FooData(…)
    }

    test("test A") {
        new TestData {
            // tests with data1 and data2
        }
    }

    test("test B") {
        new TestData {
            // another tests with data1 and data2
        }
    }
}
</code></pre>

<p>各テスト内で <code>TestData</code> trait を継承した無名クラスを作り、無名クラスのコンストラクタ内でテストを実行する。
こうすることで <code>new FooData(…)</code> の実行はテスト実行時になり、各テストごとにデータが初期化されるので、上にあげた問題が解消する。</p>

<p><a href="http://www.scalatest.org/user_guide/sharing_fixtures">Sharing fixtures</a> をみると他の方法もいろいろある。
一番上にある Calling get-fixture methods が一番単純ぽい。
この方法で例を書き換えるとこうなる。</p>

<pre><code>class FooSuite extends FunSuite {
    def fixture = new {
        val data1 = new FooData(…)
        val data2 = new FooData(…)
    }

    test("test A") {
        val f = fixture
        // tests with f.data1 and f.data2
    }

    test("test B") {
        val f = fixture
        import f._
        // another tests with data1 and data2
    }
}
</code></pre>

<p>無名クラスのメンバとしてテストデータを作る。
こっちのほうがインデント少なくていいかも。
<code>import f._</code> すれば <code>f.</code> prefix 要らないしね。
<code>new</code> のあとクラス名無くてもコンパイル通るんだ… 知らなかったよ。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[sbt build definition]]></title>
    <link href="http://tkawachi.github.io/blog/2013/09/16/sbt-build-definition/"/>
    <updated>2013-09-16T22:17:00+09:00</updated>
    <id>http://tkawachi.github.io/blog/2013/09/16/sbt-build-definition</id>
    <content type="html"><![CDATA[<p><a href="http://scalajp.github.io/sbt-getting-started-guide-ja/">始める sbt</a>
を以前読んだときは
<a href="http://scalajp.github.io/sbt-getting-started-guide-ja/basic-def/">.sbt ビルド定義</a>
のところでぐっと難しくなってよくわからなくなった。
今日復習したのでメモ。</p>

<p>最初にまとめ。</p>

<ul>
<li><code>key := value</code> は新しい設定項目を追加する関数のようなもの(<code>Setting[T]</code>)を定義する。</li>
<li><code>Setting[T]</code> の入力は変更されない。</li>
<li><code>.sbt</code> を読み込むと <code>Setting[T]</code> のリストができる。<code>Setting[T]</code> のリストは、依存関係を考慮してソートされた後に適用される。</li>
<li><code>.sbt</code> の空行で区切られた塊は Scala の式。文ではないので <code>val</code>, <code>object</code>, <code>class</code> などは書けない。</li>
<li><code>key := value</code> は <code>key.:=(value)</code> といったメソッド呼び出しを別の書き方にしたもの。</li>
<li>sbtデフォルトの設定項目は
<a href="https://github.com/sbt/sbt/blob/0.13/main/src/main/scala/sbt/Keys.scala"><code>sbt.Keys</code></a>
に定義されている。</li>
<li><code>TaskKey[T]</code> は毎回計算されるキー。</li>
<li>sbtコンソールでアクセスするときは <code>SettingKey[T]</code>, <code>TaskKey[T]</code> などを呼び出す際の第一引き数文字列を使う。</li>
<li>キーの詳細はsbtコンソールから <code>inspect</code> で確認できる。</li>
</ul>


<!-- more -->


<p><code>Setting[T]</code> は、設定を入力に与えると、新しいキーと値のペアを追加したり、既存のキーを新しい値で追加したりといった変換を表す。
変換っていうのは、なにかを入力されたら、それを変更した結果を返すということで、関数みたいな概念で捉えればいいのだろう。
<code>Setting[T]</code>は関数型の精神に則り、入力値は変更しない。</p>

<p><code>.sbt</code> ファイル中の <code>key := value</code> は変換(<code>Setting[T]</code>)を定義している。
たとえば <code>name := "hello"</code> とあれば、キーが<code>name</code>で値が<code>"hello"</code>のペアを追加・上書きする変換を定義する。
<code>T</code> は設定値の型なので、この場合は <code>Setting[String]</code> が定義されたことになる。</p>

<p><code>.sbt</code> ファイルには変換が沢山含まれているので、結果として変換(<code>Setting[T]</code>)のリストができる。</p>

<p><code>Setting[T]</code> のリストに、sbt のデフォルトの設定を入力すると、<code>.sbt</code>ファイルが反映された設定が得られる。
<code>Setting[T]</code>が入力値を変更しないのでsbtのデフォルトの設定は変更されない。</p>

<p><code>.sbt</code> ファイルで <code>name := "hello"</code> と書いたら、<code>name.:=("hello")</code> のこと。
<code>key</code> の型は <code>SettingKey[String]</code> で、 <code>:=</code> は <code>String</code> を引数にとり <code>Setting[String]</code> を返す。
間違った型の値を代入しようとした場合には(例：<code>name := 1</code>)、型チェックでエラーになる。</p>

<p><code>:=</code> メソッドの他にも <code>+=</code> （リストへの要素追加）などがある。</p>

<p>sbtに用意されている設定項目（キー）は
<a href="https://github.com/sbt/sbt/blob/0.13/main/src/main/scala/sbt/Keys.scala"><code>sbt.Keys</code></a>
object に <code>SettingKey[T]</code> 型で定義されている。
<code>.sbt</code>ファイルの内容が評価される時は <code>import sbt.Keys._</code> された状態なので、 <code>sbt.Keys._</code> はパッケージ修飾なしに参照できる。
<a href="https://github.com/sbt/sbt/blob/0.13/main/src/main/scala/sbt/Keys.scala"><code>sbt.Keys</code></a>
は重要。
設定項目を探すときにちょくちょく参照することになる気がする。</p>

<p>たとえば <code>name</code> はこんな感じ。</p>

<pre><code>val name = SettingKey[String]("name", "Project name.", APlusSetting)
</code></pre>

<p>前述のように<code>SettingKey[String]</code>であることがわかる。</p>

<p><a href="https://github.com/sbt/sbt/blob/0.13/main/src/main/scala/sbt/Keys.scala"><code>sbt.Keys</code></a>
には <code>SettingKey[T]</code> 型以外にも、 <code>TaskKey[T]</code>, <code>InputKey[T]</code>, <code>AttributeKey[T]</code> 型の値が定義されてる。
<code>compile</code> のように sbt コンソールから入力するたびに実行してくれないと困るものは
<code>TaskKey[T]</code> として定義されている。
たとえば <code>compile</code> はこんな感じ。</p>

<pre><code>val compile = TaskKey[Analysis]("compile", "Compiles sources.", APlusTask)
</code></pre>

<p><code>SettingKey[T]</code>は一度計算されると結果が保持される。
<code>TaskKey[T]</code>は毎回計算される。
<code>SettingKey[T]</code>は<code>TaskKey[T]</code>に依存できない。</p>

<p><code>InputKey[T]</code>, <code>AttributeKey[T]</code> はまだ知らない。</p>

<p>sbtコンソールから入力するのはキーコンストラクタの第一引き数の文字列。</p>

<pre><code>val scalacOptions = TaskKey[Seq[String]]("scalac-options", "Options for the Scala compiler.")
</code></pre>

<p>とあったら <code>scalac-options</code> がsbtコンソールから入力時に指定する文字列になる。
<code>sbt.Keys</code> に CamelCase で定義されたものは大体コンソール入力時には小文字、ハイフン区切りになっている。</p>

<p>キーに関する情報はsbtコンソールから <code>inspect キー名</code> で得られる。</p>

<p><code>.sbt</code> ファイルの先頭に <code>import</code> 文を複数行書ける。<code>import</code> 文の間は空行をあけなくていい。
他の <code>SettingKey[T]</code> を参照するときに使うのかな。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[akka memo]]></title>
    <link href="http://tkawachi.github.io/blog/2013/09/15/akka-memo/"/>
    <updated>2013-09-15T21:30:00+09:00</updated>
    <id>http://tkawachi.github.io/blog/2013/09/15/akka-memo</id>
    <content type="html"><![CDATA[<p>Scala 2.10 から付いてくる Akka の Actor についてのお勉強メモ。
全然まとまっていないが晒しておく。</p>

<!-- more -->


<h2>概念</h2>

<h3>Actor</h3>

<p><code>akka.actor.Actor</code>。
メッセージを受けて処理をする人。</p>

<h3>Mailbox</h3>

<p>Actorへのメッセージが溜まるところ。</p>

<h3>Supervision</h3>

<p>Actor間の依存関係のこと。
Actorインスタンスはツリー構造になっている。
親が supervisor となる。</p>

<p>Actor が失敗したらどうするかは supervisor の actor が制御する。</p>

<p>親 actor が shutdown したら、その子どもは全て shutdown する。</p>

<p>タスクのまとまり毎にサブツリーを形成するようにすると良いらしい。</p>

<h3>Actor Path</h3>

<p>Actorインスタンスにはツリー構造上の位置を表す文字列がついており、これを actor path と呼ぶ。
<code>/</code>, <code>/user</code>, <code>/user/abc</code> など。</p>

<h3>ActorSystem</h3>

<p><code>akka.actor.ActorSystem</code>。
ツリー全体を管理するもの。
ActorSystemはスレッドを何本も使う重い構造なので沢山作りすぎない。</p>

<h3>Router</h3>

<p>Actor の一種。メッセージを受け取って他の actor に投げる(Routingする)。
投げられる側を routee と呼ぶ。
Routee は router の子どもになる。</p>

<p>以下の様な router が提供されている。どのようにルーティングするかは名前から大体想像がつく。
ロードバランサ的なやつですかね。</p>

<ul>
<li>akka.routing.RoundRobinRouter</li>
<li>akka.routing.RandomRouter</li>
<li>akka.routing.SmallestMailboxRouter</li>
<li>akka.routing.BroadcastRouter</li>
<li>akka.routing.ScatterGatherFirstCompletedRouter</li>
<li>akka.routing.ConsistentHashingRouter</li>
</ul>


<h3>Props</h3>

<p><code>akka.actor.Props</code>。
Actorをインスタンス化する際の設定。
Immutable なので複数の actor をインスタンス化する際に使いまわせる。</p>

<h2>ライフサイクル</h2>

<p>生まれてから死ぬまで。</p>

<p>停止信号を受け取ると以下の手順で止まる。</p>

<ol>
<li>mailbox メッセージの処理をやめる</li>
<li>子どもに停止信号を送る</li>
<li>全ての子どもから停止完了がくるのを待つ</li>
<li>自分自身の停止完了プロセスを実行

<ol>
<li><code>postStop()</code> を呼び出す</li>
<li>mailbox をダンプ</li>
<li><code>DeathWatch</code> に停止完了を知らせる</li>
<li>親に停止完了を知らせる</li>
</ol>
</li>
</ol>


<h3>止めかたのパターン</h3>

<ul>
<li>ActorSystem を shutdown() する。</li>
<li>PoisonPill を actor に送る。通常メッセージと同じように mailbox に送られ、処理されるときに actor が停止する。</li>
<li><code>context.stop(self)</code>, <code>context.stop(child)</code> で止める。</li>
</ul>


<h3>殺しかた</h3>

<ul>
<li>Kill を送ると即座に死ぬ</li>
</ul>


<h3>問題が起きたときの判断</h3>

<p>以下のいずれか。</p>

<ul>
<li>Resume</li>
<li>Restart</li>
<li>Terminate</li>
<li>Escalate</li>
</ul>


<h3>Restart</h3>

<ul>
<li>子どもをterminate。自分をterminate。</li>
<li>子どもの mailbox は保持される。 mailbox を破棄したい時は supervisor が terminate, recreate すること。</li>
</ul>


<h3>ストラテジー</h3>

<ul>
<li>one-for-one strategy &mdash; default

<ul>
<li>Restart (defaultDecider)</li>
</ul>
</li>
<li>all-for-one strategy</li>
</ul>


<p><a href="http://doc.akka.io/docs/akka/snapshot/general/supervision.html#supervision-restart">What Restarting Means</a></p>

<p>失敗は３つのカテゴリに分けられる。</p>

<ul>
<li>特定のメッセージを処理する際のプログラムエラー</li>
<li>メッセージを処理する際に使われる外部リソースの一時的なエラー</li>
<li>Actorの内部状態が壊れた</li>
</ul>


<p>内部状態が壊れたら内部状態を破棄しなければならない。Supervisorや他の子どもが壊れた内部状態の影響を受けなければ、restartするのがベスト。
Restartの際には内部的に新しい Actor がインスタンス化され、ActorRefの参照しているものが切り替わる。
ActorRef の存在意義のひとつは、この切り替え。</p>

<p>Actorが内部で作った子 Actor の ActorRef を外部に保持していると、
Actor restart 時に無効な参照になる。</p>

<p>ガーディアン直下の actor に対応する ActorRef は ActorSystem 終了時まで有効だろうと思う。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ScalaTestでMockito]]></title>
    <link href="http://tkawachi.github.io/blog/2013/08/26/mockito-scala/"/>
    <updated>2013-08-26T10:14:00+09:00</updated>
    <id>http://tkawachi.github.io/blog/2013/08/26/mockito-scala</id>
    <content type="html"><![CDATA[<p>ScalaTestでMockitoを使うためのお勉強ノート</p>

<h2>Setup</h2>

<p><code>build.sbt</code> に追加。</p>

<pre><code>libraryDependencies ++= Seq(
  "org.scalatest" %% "scalatest" % "1.9.1" % "test",
  "org.mockito" % "mockito-core" % "1.9.5" % "test"
)
</code></pre>

<p>テストで <code>MockitoSugar</code> を mixin し、以下の import 行を追加。</p>

<pre><code>import org.mockito.Matchers._
import org.mockito.Mockito._
</code></pre>

<h2>Mock作成</h2>

<pre><code>// ClassToMock のモックを作成
val m = mock[ClassToMock]
</code></pre>

<p>作ったモックはデフォルトで全メソッドコールに対して <code>null</code> を返す。
メソッドの戻り値として<code>null</code>ではなくモックを返したい時は次のようにする。</p>

<pre><code>// メソッド呼び出しでモックを返すモック
mock[ClassToMock](RETURNS_MOCKS)
// 返されたモックもモックを返すモック
mock[ClassToMock](RETURNS_DEEP_STUBS)
</code></pre>

<h2>引数に応じて戻り値を変える</h2>

<p><code>when(メソッド呼び出し).thenReturn(戻り値)</code> で登録する。
メソッド呼び出し部の引き数には <code>any</code> で任意の型の任意の値に、<code>anyString</code>, <code>anyBoolean</code>, <code>anyByte</code>, <code>anyChar</code>などで基本的な型の任意の値に <code>anyVararg</code> で任意の可変引き数にマッチさせることができる。</p>

<pre><code>// m.method1(何か) が呼ばれたら 10 を返す
when(m.method1(any)).thenReturn(10)
</code></pre>

<p>引数が２つ以上あり、いずれかで <code>any</code> などのマッチャーを使った場合には、他の引き数もマッチャーにする必要がある。
オブジェクトが等しいことを示すマッチャーは <code>eq(obj)</code> で作れる。</p>

<p>後から登録したものが先にマッチするので、条件のゆるいもの（マッチ範囲が広いもの）を先に書く。</p>

<h3>１回目、２回目で違う値を返す</h3>

<p><code>thenReturn()</code> の可変引き数版を使う</p>

<pre><code>// 最初は 10, 次は 20, それ以降はずっと 30 を返す
when(m.method1()).thenReturn(10, 20, 30)
</code></pre>

<h2>例外を起こす</h2>

<pre><code>// method1() が呼ばれたら例外を起こす
when(m.method1()).thenThrow(new RuntimeException("Gau gau"))
</code></pre>

<p><code>thenReturn</code> と同じように１回目、２回目で違う例外を起こすことも可能。
むしろ <code>thenReturn</code> と組み合わせることができる。</p>

<pre><code>when(m.method1())
  .thenReturn(10, 20) // １回目は10, ２回目は20を返す
  .thenThrow(new FooException, new BarException) // ３、４回目は例外
  .thenReturn(30) // ５回目以降は30を返す
</code></pre>

<h2>オブジェクトの一部をモックする(spy)</h2>

<p><code>mock[ClassToMock]</code> はフルのモック。一部だけモックしたい場合はこっち。<code>spy</code>と呼ぶ。</p>

<pre><code>// obj は普通のオブジェクト
val s = spy(obj)
// s.method1(何か) が呼ばれたら obj の実装を使わずに 10 を返す。
doReturn(10).when(s).method1(any[ClassOfArg])
</code></pre>

<p><code>thenReturn</code> が <code>doReturn</code> になって順番が代わり、メソッド呼び出しも <code>when</code> の外に出す。
<code>thenReturn</code>の書き方では実際のメソッドが呼ばれるので、呼ばれては困るときにこちらの書き方をする。</p>

<p>この記法の場合は <code>any</code> を使うときに型を指定しなければならなかった
（理由はわかってない）。</p>

<h2>メソッドが呼び出されたことを確認する(verify)</h2>

<p><code>when()</code>, <code>thenReturn()</code>, <code>doReturn()</code> などは関数呼び出しの前に用意する。
用意したものがテスト中で呼び出されなくても問題ない。</p>

<p>呼び出されたことを確認するには <code>verify()</code> を使う。</p>

<pre><code>// テストを実行
m.method1(123);
// method1() が何らかの整数引き数で呼び出されたことを確認
verify(m).method1(anyInt);
</code></pre>

<p>複数回呼び出されたことを確認するときは、<code>verify()</code>の第二引き数で回数指定をする。</p>

<pre><code>// 2回呼び出されたことを確認
verify(m, times(2)).method1(anyInt)
// 少なくとも2回
verify(m, atLeast(2)).method1(anyInt)
// 多くとも3回
verify(m, atMost(3)).method1(anyInt)
</code></pre>

<h3>呼び出されてないことを確認する</h3>

<p><code>never</code> を使う。</p>

<pre><code>// 一度も呼ばれてないことを確認
verify(m, never).method1(anyInt)
</code></pre>

<h2>より進んだ使い方</h2>

<p><a href="http://docs.mockito.googlecode.com/hg/latest/org/mockito/Mockito.html">Mockitoのドキュメント</a>
に書いてある。</p>
]]></content>
  </entry>
  
</feed>
