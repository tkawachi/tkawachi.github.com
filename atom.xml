<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[tkawachi Blog]]></title>
  <link href="http://tkawachi.github.io/atom.xml" rel="self"/>
  <link href="http://tkawachi.github.io/"/>
  <updated>2013-11-23T22:07:25+09:00</updated>
  <id>http://tkawachi.github.io/</id>
  <author>
    <name><![CDATA[KAWACHI Takashi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Play Framework 2.2 Scala 最初の1週間で困った雑多なこと]]></title>
    <link href="http://tkawachi.github.io/blog/2013/11/23/starting-play/"/>
    <updated>2013-11-23T21:40:00+09:00</updated>
    <id>http://tkawachi.github.io/blog/2013/11/23/starting-play</id>
    <content type="html"><![CDATA[<p>Play Framework 2.2.1 + Scala を触り始めて一週間くらいたった。
触りながら困った点（というか「疑問に思った」程度のものが多いが）をメモしていたので晒しておく。
雑なメモで無知を晒すのは恥ずかしいが、同じことではまる人がいるかもしれないもんね。</p>

<p>間違っているところがあったらコメントで教えてもらえると大変嬉しいです。</p>

<!-- more -->


<h2>Play 関連</h2>

<h3>Q: app/assets/ と public/ の違いは？</h3>

<p>A: app/assets は CoffeeScript, LESS など preprocess するもの。public はしないもの。</p>

<h3>Q: bindFromRequest すると Cannot find any HTTP Request here って出るよ。</h3>

<p>A: Action の先頭に <code>implicit request =&gt;</code> を付ける。
<code>Action { implicit request =&gt; ... }</code></p>

<p>Action.apply() がオーバーロードされてて、引数が call by name のもの関数のものがある。</p>

<pre><code>def apply(block: =&gt; Result)
def apply(block: Request =&gt; Result)
</code></pre>

<p><code>implicit request =&gt;</code> を付けたときは引数が関数の方。
request は implicit parameter。</p>

<h3>Q: なぜ Cannot find any HTTP Request here というエラーが出るの？</h3>

<p>A: <code>scala.annotation.implicitNotFound</code> で annotation されているから。</p>

<h3>Q: bindFromRequest がエラーの時、どうやってエラー表示する？</h3>

<p>A: <code>Form#fold</code> を使う</p>

<h3>Q: view 内で import したい</h3>

<p>A: <code>@import some.package.MyClass</code>
view の先頭（かつ、パラメータの後！）でしか import 出来ないので注意。</p>

<h3>Q: view 先頭にあるパラメータの型指定で、@import したクラスが使えない</h3>

<p>A: どうやらそういうものらしい。パッケージ名フル修飾で書く。</p>

<h3>Q: @helper.inputText() 等で出力される input tag に属性を付けたい（class とか）</h3>

<p>A: Symbol &ndash;> Any のタプルをずらずらと渡す。</p>

<pre><code>@helper.inputText(userForm("name"), 'id -&gt; "name", 'size -&gt; 30)
</code></pre>

<h3>Q: @helper.inputText() 等で出力される input tag に紐づく label tag の名前を変えたい。</h3>

<p>A: &lsquo;_label &ndash;> &ldquo;ほげ&rdquo; を追加する。</p>

<pre><code>@helper.inputText(userForm("name"), '_label -&gt; "ほげ")
</code></pre>

<p><code>_label</code> 以外の特別なキーはここ。</p>

<p><a href="http://www.playframework.com/documentation/2.2.x/ScalaCustomFieldConstructors">http://www.playframework.com/documentation/2.2.x/ScalaCustomFieldConstructors</a></p>

<h3>Q: submit ボタン表示はどうするんだっけ？</h3>

<p>A:</p>

<pre><code>@helper.form(...) {
  ...
  &lt;button type="submit"&gt;&lt;/button&gt; // ←ここに直接書く。
}
</code></pre>

<h3>Q: Form の required という表示を消したい。<code>&lt;dd class="info"&gt;Required&lt;/dd&gt;</code>←これ</h3>

<p>A: <code>'_showConstraints -&gt; false</code> を <code>@helper.inputFoo()</code> に渡す。</p>

<h3>Q: war にできる？</h3>

<p>A: war にできないぽい。
<a href="http://stackoverflow.com/questions/14985783/deploy-play-as-a-war-file-into-a-servlet-container-even-if-it-uses-jpa-heavily">http://stackoverflow.com/questions/14985783/deploy-play-as-a-war-file-into-a-servlet-container-even-if-it-uses-jpa-heavily</a></p>

<h3>Q: deploy は?</h3>

<p>A: play dist で zip にして展開するのが良さそう</p>

<h3>Q: Controller action の URL を得るには？</h3>

<p>A: <code>routes.MyController.action(arg)</code></p>

<p><a href="http://www.playframework.com/documentation/2.2.x/ScalaRouting">http://www.playframework.com/documentation/2.2.x/ScalaRouting</a></p>

<h3>Q: Log の出し方は？</h3>

<p>A: <code>play.api.Logger.info()</code> など。</p>

<h2>SecureSocial 関連</h2>

<h3>Q: ユーザ登録まわりはモジュールある？ Rails の devise みたいな。</h3>

<p>A: SecureSocial か play2-auth</p>

<ul>
<li><a href="http://securesocial.ws/">http://securesocial.ws/</a></li>
<li><a href="https://github.com/t2v/play2-auth">https://github.com/t2v/play2-auth</a></li>
</ul>


<h3>Q: SecureSocial で SES からメール送れる？</h3>

<p>A: SES の smtp interface で送れる。</p>

<h3>Q: SecureSocail のコントローラの path を view から逆引きするのはどうしたらいいのか?</h3>

<p>A: <code>securesocial.core.providers.utils.RoutesHelper.login()</code> とか</p>

<h3>Q: SecureSocial で提供されるページとメールは国際化できるか？</h3>

<p>A: <a href="http://securesocial.ws/guide/views-customization.html">http://securesocial.ws/guide/views-customization.html</a> の手順でできそう。</p>

<h3>Q: メールアドレスとパスワードで登録したユーザと、Google認証のユーザが別ユーザになる。</h3>

<p>統合する方法は用意されているか？
A: 用意されていない。</p>

<ul>
<li><a href="https://groups.google.com/forum/#!topic/securesocial/at-qCKXvsE0">https://groups.google.com/forum/#!topic/securesocial/at-qCKXvsE0</a></li>
<li><a href="https://github.com/jaliss/securesocial/issues/14">https://github.com/jaliss/securesocial/issues/14</a></li>
</ul>


<h2>DB 関連</h2>

<h3>Q: evolution で manual rollback するには?</h3>

<p>A: できない!</p>

<p><a href="http://stackoverflow.com/questions/10069217/rolling-an-evolution-back">http://stackoverflow.com/questions/10069217/rolling-an-evolution-back</a></p>

<h3>Q: play-slick 使った時に migration 管理は含まれているのか？</h3>

<p>A: evolutions の 1.sql を吐き出してくれる機能はある。</p>

<h3>Q: slick の for で foreach メソッドが無いとか言われる</h3>

<p>A: <code>import scala.slick.driver.MySQLDriver.simple._</code>
したら通った。どういうこと..</p>

<h3>Q: Slick で JodaTime の DateTime 使いたい。</h3>

<p>A: <a href="https://github.com/tototoshi/slick-joda-mapper">https://github.com/tototoshi/slick-joda-mapper</a></p>

<h3>Q: Slick で DateTime の大小比較はどうする？</h3>

<p>A: &lt; でいいっぽい。
<code>import com.github.tototoshi.slick.JodaSupport._</code>が必要。</p>

<h3>Q: DateTime 比較時にこんなエラーが起きる</h3>

<pre><code>com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ':26:48.548+09:00' at line 1
</code></pre>

<p>A: slick-joda-mapper が古かった(0.1.0だった)。0.4.0 にあげたら解消した。</p>

<h3>Q: Slick で発行されている SQL を表示するには?</h3>

<p>A: <a href="http://stackoverflow.com/questions/14840010/how-do-you-print-the-select-statements-for-the-following-slick-queries">http://stackoverflow.com/questions/14840010/how-do-you-print-the-select-statements-for-the-following-slick-queries</a> によるとできない。</p>

<h3>Q: Slick から value filter is not a member of models.MyModel といわれる。</h3>

<p>A: <code>Query()</code> でくるむといい。</p>

<h3>Q: play test すると Attempting to obtain a connection from a pool that has already been shutdown. と出る。</h3>

<p>A:  <a href="http://d.hatena.ne.jp/tototoshi/20130329/1364484806">http://d.hatena.ne.jp/tototoshi/20130329/1364484806</a></p>

<pre><code>FakeApplication(
  additionalConfiguration =
    inMemoryDatabase(name = "default", options = Map("DB_CLOSE_DELAY" -&gt; "-1"))
)
</code></pre>

<h3>Q: <code>new WithBrowser(app = dbApp)</code> （dbApp は DB_CLOSE_DELAY 指定した FakeApplication）でエラーになる</h3>

<p>A: 第一引き数 webDriver も指定したらエラーでなくなった。（初期化順の問題？）</p>

<pre><code>new WithBrowser(webDriver = Helpers.HTMLUNIT, app = dbApp) 
</code></pre>

<h3>Q: Play で環境によって設定を変える仕組みが用意されているか？</h3>

<p>A: <code>-Dconfig.file</code> で設定ファイルを切り替える</p>

<h3>Q: play-flyway で本番系 migration はどうやるの?</h3>

<p>A: <code>-Ddb.default.migration.auto=true</code></p>

<p>最初まちがって <code>-Ddb.default.migration.initOnMigrate=true</code> を指定して悩んでた。</p>

<h3>Q: Play で gzip を有効化できるか？</h3>

<p>A: GzipFilter でできるっぽい。</p>

<p><a href="http://www.playframework.com/documentation/2.2.x/GzipEncoding">http://www.playframework.com/documentation/2.2.x/GzipEncoding</a></p>

<p>appDependencies に filters を追加する必要あり。</p>

<h3>Q: Slick で MySQL に接続したら文字化けした</h3>

<p>A:  character_set_client, character_set_server が utf8mb4 になっていることを
確認する。</p>

<p>サーバとクライアントのネゴシエーションで決まる。
Slick での character_set_client, character_set_server の確認方法。</p>

<pre><code>import scala.slick.session.Database
import Database.threadLocalSession
import scala.slick.jdbc.{GetResult, StaticQuery =&gt; Q}

val jdbcUrl = "jdbc:mysql://localhost:3306/my_db?user=myUser&amp;password=myPassword"
Database.forURL(jdbcUrl, driver = "com.mysql.jdbc.Driver") withSession {
  val q = "SHOW VARIABLES LIKE 'char%'"
  Q.queryNA[(String, String)](q).foreach(println)
}
</code></pre>

<p>サーバの設定で character_set_server を utf8mb4 に設定し、 JDBC には
characterEncoding=utf8mb4 をつけないのが正解ぽい。
JDBC URL に characterEncoding=utf8mb4 をつけると、例外がおきるので注意。</p>

<h3>Q: Play + Slick で driver に応じて、処理を変えたい。</h3>

<p>A: こんな感じ。</p>

<pre><code>import play.api.db.slick.DB
import scala.slick.driver.MySQLDriver
if (DB("default").driver == MySQLDriver) {...}
</code></pre>

<h3>Q: MySQL 用に CREATE TABLE に CHARACTER SET 指定をしたいが、テストの H2 でエラー。</h3>

<p>A: <code>/*! */</code> でくくると良い。</p>

<p><a href="http://stackoverflow.com/questions/15885814/use-mysql-in-dev-prod-and-h2-in-test">http://stackoverflow.com/questions/15885814/use-mysql-in-dev-prod-and-h2-in-test</a></p>

<p><code>/*! CHARACTER SET utf8mb4 */;</code>
をつけておくと MySQL でだけ処理され、H2では処理されない。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Play framework 2.2.1 scala でユーザ登録]]></title>
    <link href="http://tkawachi.github.io/blog/2013/11/17/play-2-dot-2-scala-user-login/"/>
    <updated>2013-11-17T18:36:00+09:00</updated>
    <id>http://tkawachi.github.io/blog/2013/11/17/play-2-dot-2-scala-user-login</id>
    <content type="html"><![CDATA[<p>Play framework 2.x を触り始めていて、まず最初にユーザ登録とログインを
扱いたいと思った。
Rails であれば devise で、というところだが、Play ではどうなっているのだろう？</p>

<p>Sample としてついてくる zentask や、
「play scala ユーザ登録」でググって上の方に出てくる
<a href="http://akiomik.hatenablog.jp/entry/2013/02/07/211054">ペ</a>
<a href="http://how-to-use-playframework-20.readthedocs.org/en/latest/subdocs/initial_create_application.html">ー</a>
<a href="http://d.hatena.ne.jp/sy-2010/20110517/1305650450">ジ</a>
を見ると、いずれもパスワードを生で保存している。</p>

<p>パスワードは生で保存していると何かの拍子に痛い目に合うので、真似したくない。
きっと Rails の devise みたいに再利用できるコンポーネントがあるだろうから、
それを使いたい。</p>

<p>Google+ のコミュニティで訪ねてみたところ<a href="http://securesocial.ws/">SecureSocial</a> と
<a href="https://github.com/t2v/play2-auth">play2-auth</a>
を教えてもらった。
SecureSocial を試してみる。</p>

<!-- more -->


<p>Play は 2.2.1, Scala でやる。</p>

<p>プロジェクト作成。アプリ名はログインしたいだけだから <code>just-login</code> にする。</p>

<pre><code>$ play new just-login
</code></pre>

<p><a href="http://securesocial.ws/guide/installation.html">http://securesocial.ws/guide/installation.html</a> に従って進めていく。</p>

<p>project/Build.scala を追加。</p>

<pre><code>import sbt._
import Keys._

object ApplicationBuild extends Build {
    val appName         = "just-login"
    val appVersion      = "1.0-SNAPSHOT"

    val appDependencies = Seq(
        "securesocial" %% "securesocial" % "2.1.2"
    )
    val main = play.Project(appName, appVersion, appDependencies).settings(
        resolvers += Resolver.url("sbt-plugin-releases", new URL("http://repo.scala-sbt.org/scalasbt/sbt-plugin-releases/"))(Resolver.ivyStylePatterns)
    )
}
</code></pre>

<p>重複した情報になるので、 build.sbt からは <code>name</code> と <code>version</code> を削除した。</p>

<p>conf/route にルーティング追加。それっぽいエンドポイントが一式備わってて、それっぽい感じ。</p>

<pre><code># Login page
GET     /login                      securesocial.controllers.LoginPage.login
GET     /logout                     securesocial.controllers.LoginPage.logout

# User Registration and password handling 
GET     /signup                     securesocial.controllers.Registration.startSignUp
POST    /signup                     securesocial.controllers.Registration.handleStartSignUp
GET     /signup/:token              securesocial.controllers.Registration.signUp(token)
POST    /signup/:token              securesocial.controllers.Registration.handleSignUp(token)
GET     /reset                      securesocial.controllers.Registration.startResetPassword
POST    /reset                      securesocial.controllers.Registration.handleStartResetPassword
GET     /reset/:token               securesocial.controllers.Registration.resetPassword(token)
POST    /reset/:token               securesocial.controllers.Registration.handleResetPassword(token)
GET     /password                   securesocial.controllers.PasswordChange.page
POST    /password                   securesocial.controllers.PasswordChange.handlePasswordChange

# Providers entry points
GET     /authenticate/:provider     securesocial.controllers.ProviderController.authenticate(provider)
POST    /authenticate/:provider     securesocial.controllers.ProviderController.authenticateByPost(provider)
GET     /not-authorized             securesocial.controllers.ProviderController.notAuthorized
</code></pre>

<p>次に <code>conf/play.plugins</code> を作成し、以下の内容を記述。
ユーザ名とパスワードでログインしたいだけなので、
Twitter やら Facebook やらでログインするためのプラグインはざっくり削る。</p>

<pre><code>1500:com.typesafe.plugin.CommonsMailerPlugin
9994:securesocial.core.DefaultAuthenticatorStore
9995:securesocial.core.DefaultIdGenerator
9996:securesocial.core.providers.utils.DefaultPasswordValidator
9997:securesocial.controllers.DefaultTemplatesPlugin
9998:service.UserServiceImpl
9999:securesocial.core.providers.utils.BCryptPasswordHasher
10004:securesocial.core.providers.UsernamePasswordProvider
</code></pre>

<p><code>9998:service.UserServiceImpl</code> の行に書いた <code>service.UserServiceImpl</code> は
自分の環境に合わせて実装する必要がある。</p>

<p><a href="https://github.com/jaliss/securesocial/blob/master/samples/scala/demo/app/service/InMemoryUserService.scala">InMemoryUserService.scala</a>
の内容をコピってきて、パッケージ名を <code>service</code> に、クラス名を <code>UserServiceImpl</code> に
変えて、 <code>app/service/UserServiceImpl.scala</code> として保存する。</p>

<p><a href="http://securesocial.ws/guide/configuration.html">http://securesocial.ws/guide/configuration.html</a> にのっとって
<code>conf/application.conf</code> に <code>smtp</code> の設定と、 <code>include "securesocial.conf"</code> を書く。
<code>conf/securesocial.conf</code> は <code>Sample configuration</code> の内容を書く。
<code>assetsController=controllers.ReverseMyCustomAssetsController</code> は
Asset のコントローラを自前で作っているときだけ必要ぽいので、コメントアウトする。</p>

<p><a href="https://github.com/typesafehub/play-plugins/blob/master/mailer/src/main/scala/com/typesafe/plugin/MailerPlugin.scala">MailerPlugin のソース</a>
を眺めるとわかるように <code>smtp.mock = true</code> を設定しておけば実際のメールは送信されず、
コンソールにメールの内容が出力される。</p>

<pre><code>smtp {
    ... 他の設定
    mock = true
}
</code></pre>

<p>ここまでで、ユーザ登録とログイン、ログアウト、パスワード忘れが実現できた。
パスワードが生で保存されることはなく、<code>BCryptPasswordHasher</code> によって生成された hash が格納される。</p>

<p>UserService はメモリ上じゃなく、DBへ格納するように実装することになる。
その際は
<a href="https://github.com/jaliss/securesocial/pull/163/files">https://github.com/jaliss/securesocial/pull/163/files</a>
のコードが参考になりそうだった。</p>

<h2>まとめ</h2>

<ul>
<li><a href="http://securesocial.ws/">SecureSocial</a> を使えば Play 2.2 + scala でユーザ登録・ログイン・パスワード忘れが簡単に実現できる</li>
<li>Rails の devise のように DB の schema は出してくれないので、比べると少し面倒かな&hellip;</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Haxe で call-by-name したい]]></title>
    <link href="http://tkawachi.github.io/blog/2013/11/01/haxe-call-by-name/"/>
    <updated>2013-11-01T19:18:00+09:00</updated>
    <id>http://tkawachi.github.io/blog/2013/11/01/haxe-call-by-name</id>
    <content type="html"><![CDATA[<p>先日 Haxe で Option 関連の関数を定義した時、 <code>getOrElse()</code> は次のような定義にしていた。</p>

<pre><code>public static function getOrElse&lt;A&gt;(opt: Option&lt;A&gt;, els: A) {
  return switch (opt) {
  case Some(v): v;
  case None: els;
  }
}
</code></pre>

<p>scala.Option の <code>getOrElse()</code> ぽく使いたかったのだが、実際に使ってみるとなんか違う。</p>

<pre><code>opt.getOrElse(sideEffectFunction());
</code></pre>

<p>上で <code>sideEffectFunction()</code> は何らかの副作用をもつ関数だ。
Scala の場合、 <code>opt</code> に値が入っていた場合には <code>sideEffectFunction()</code> は評価されない。
副作用も発生しない。
上で定義した Haxe 用 <code>getOrElse()</code> では <code>opt</code> の内容によらず <code>sideEffectFunction()</code> が評価され、副作用が発生する。</p>

<p>関数を呼び出すときには、まず引数を評価してから関数の実行に移るので、当たり前といえば当たり前だった。</p>

<!-- more -->


<p>Scala には call-by-name が言語上用意されているおり、
scala.Option の <code>getOrElse()</code> はこれを利用している。
型を確認すると <code>final def getOrElse[B &gt;: A](default: ⇒ B): B</code> となっている。
<code>⇒ B</code> が引数の型だが <code>⇒</code> を付けることにより、関数呼び出し前には評価されず、関数内で <code>default</code> を参照したところで評価されるようになっている(call-by-name)。
なお <code>[B &gt;: A]</code> は型の境界で、B は A の supertype であることを表している。
<code>default</code> に何かを入れると <code>A</code> と <code>default</code> の型との共通 supertyper を探して <code>B</code> を推論してくれる。
いいなあ。Scala。</p>

<h2>Using callback</h2>

<p>さて Haxe には call-by-name が無い。
JavaScript も call-by-name が無いが、彼らは callback でそれを代用する。
Haxe でも同じようにできる。</p>

<pre><code>public static function getOrElse&lt;A&gt;(opt: Option&lt;A&gt;, els: Void -&gt; A) {
  return switch (opt) {
  case Some(v): v;
  case None: els();
  }
}
</code></pre>

<p><code>els</code> 部を関数渡すようにしておけば、実際に <code>opt</code> が <code>None</code> のときだけ <code>els</code> を評価することができる。
このとき呼び出し元は以下のようになる。</p>

<pre><code>opt.getOrElse(function() { return sideEffectFunction(); });
// function が return ひとつだけのときは以下のように省略できるが、まだ長い。
opt.getOrElse(function() return sideEffectFunction());
</code></pre>

<p>Haxe では関数リテラルを短く書く方法がなく、return を省略できないため長ったらしい。
仮にこれが CoffeeScript だったとすると、</p>

<pre><code>opt.getOrElse(-&gt; sideEffectFunction())
</code></pre>

<p>と書くことが出来ただろう。
しかしないものねだりをしてもしょうがない。</p>

<h2>Using macro</h2>

<p>もうすこし考えてみたところ、macro 機能を使えば scala ぽいことができることに気がついた。
Macro はコンパイル時に実行されるコードで、プログラムを変更することができる。
Macro というと「怖い。黒魔術！」と身構えてしまうかもしれないが、ひどく怖いわけではない。</p>

<p>プログラムをコンパイルするときはテキストを読み込んで抽象構文木を作る。
C の macro はテキストの段階で置き換えを行うが、 Haxe の macro は抽象構文木の段階で変換を行う。
C では C の文法ではないテキストを macro で処理することができる。
Haxe では、まず抽象構文木を作る必要があるので、元々存在しない文法の文字列は macro を使ってどうこうできない。
<a href="http://haxe.org/manual/macros">Haxe の macro 説明ページ</a>では
「文法が崩れないので解読不能にならない。嬉しいよね！」と主張している。
なお、Scala の macro も Haxe と同じ。
<a href="http://goo.gl/2D99Nl">Wikipediaによると</a> それぞれ Text substitution macros と Syntactic macros という名前で呼ばれるらしい。</p>

<p>Macro を使って書いたオレオレ <code>getOrElse()</code> は以下のとおり。</p>

<pre><code>import haxe.macro.Expr;

macro public static function getOrElse(opt: Expr, els: Expr) {
  return macro switch ($opt) {
  case Some(v): v;
  case None: $els;
  }
}
</code></pre>

<p>関数宣言の頭に <code>macro</code> と付けることで、<code>getOrElse()</code> が macro であることを示している。
Macro 引数の型は基本的に <code>haxe.macro.Expr</code> 型であり、これは抽象構文木上の式を表す。
木上で式を式に変換するわけだから、戻り値も <code>Expr</code> 型だ。
<code>return</code> の次にある <code>macro</code> は、以降の式を <code>Expr</code> に変えてくれる便利なもの。
<code>opt</code> や <code>els</code> の参照は、<code>$</code> prefix を付けて行う。
正直、まだ完全にわかった気はしていないが、 <code>getOrElse()</code> の定義はこれで十分。</p>

<p>呼び出し方は scala と同じ</p>

<pre><code>opt.getOrElse(sideEffectFunction());
</code></pre>

<p>となる。
<code>getOrElse()</code> は macro なので、上の呼び出しはコンパイル時に以下に展開される。</p>

<pre><code>// opt.getOrElse(sideEffectFunction()); が以下に置き換えられる。
switch (opt) {
  case Some(v): v;
  case None: sideEffectFunction();
};
</code></pre>

<p>展開結果を見るとわかるように <code>opt</code> が <code>Some(v)</code> の時には <code>sideEffectFunction()</code> は評価されない。やった。Scala ぽくなった。</p>

<p>なお、macro 引き数の <code>els</code> は macro 定義内で何度でも参照でき、各々が <code>sideEffectFunction()</code> に展開されるため、評価回数が複数回になりうるというところは call-by-name と同じだ。</p>

<h3>まって、それ type safe じゃなくない？</h3>

<p>むぐぐ。
たしかに <code>switch</code> に展開するだけなので <code>els</code> に対する型の制約はない。
Macro でなんとか出来そうな気もするが将来の課題ということに。</p>

<h2>再び callback</h2>

<p>Callback での不満点は無名関数の記法が長いということだったので、macro でそれを解決すれば満足できるかもしれない。
ただし Haxe の文法にないものは macro でどうしようもないので <code>-&gt; sideEffectFunction()</code> のような書き方はできない。</p>

<p>例えばこんな感じ。</p>

<pre><code>macro public static function fn(e: Expr) {
  return macro function() { return $e; };
}
</code></pre>

<p>を mixin すれば callback 版 <code>getOrElse()</code> は以下のように呼び出せる。</p>

<pre><code>opt.getOrElse(sideEffectFunction().fn());
</code></pre>

<p>ここが妥協点かなあ。</p>

<h2>まとめ</h2>

<ul>
<li>Haxe の macro を使うと抽象構文木レベルでプログラムを変更できる</li>
<li>Haxe にも call-by-name あったらいいのに</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Haxe で Option用の関数を定義してみた話]]></title>
    <link href="http://tkawachi.github.io/blog/2013/10/31/haxe-optionop/"/>
    <updated>2013-10-31T20:35:00+09:00</updated>
    <id>http://tkawachi.github.io/blog/2013/10/31/haxe-optionop</id>
    <content type="html"><![CDATA[<p>最近 JavaScript で何かを書くことになって困っている。
JavaScript はそれなりに仕事で触れて、それなりに理解はしているが、どうにも好きになれない。
CoffeeScript もそれなりに触れたが、短く書けて式中心の記法ができるものの、それ以外は JavaScript と同じ。
何も変わっていない。</p>

<p>僕の問題（苦手）意識は <a href="http://www.haskell.org/haskellwiki/The_JavaScript_Problem">The JavaScript Problem</a>
によく表されている。</p>

<ol>
<li>JavaScript sucks.</li>
<li>We need JavaScript.</li>
</ol>


<p>もうちょっとマシな言語で書きたいと常々思っていた。</p>

<p>AltJS のなかで TypeScript は触ったが、Haxe は触っていなかった。
理由は「Haxe が吐き出す JavaScript はとても人間が読めるものじゃない」とどこかで聞いていたから。
いざって時には生成された JavaScript が読める形じゃないと困る。</p>

<p>今回ふとしたきっかけで Haxe を触ってみた。
さわってみるとかなり好感触。
出力された JavaScript はそんなに変なことになってなくて普通に読める。
やはり自分で触ってみないとダメだな。
代数的データ型があるなど TypeScript より型機能が強い感じ。</p>

<!-- more -->


<p>本題。
Scala でいうところの <code>scala.Option</code> に対応する型として Haxe には <code>haxe.ds.Option</code> という enum がある。
ただし Scala の case object と違い、Haxe の enum にはメソッドが定義できない。
最初は <code>switch case</code> を使って Option の分岐を書いていた。</p>

<pre><code>var opt: Option&lt;Int&gt; = ...;
switch(opt) {
case Some(v): trace(v);
case None: trace('None');
}
</code></pre>

<p>的な。
これでも悪くないが Scala ぽく書きたかったので、それっぽくできないか考えてみた
（きっと他の人がどこかでやってる気がするけど）。</p>

<p>Haxe の <a href="http://haxe.org/manual/using">using mixin</a> を使えば同じようなことができそう。
次のようなものを作って</p>

<pre><code>import haxe.ds.Option;
class OptionOp {
  public static function map&lt;A,B&gt;(opt: Option&lt;A&gt;, f: A -&gt; B): Option&lt;B&gt; {
    return switch (opt) {
    case None: None;
    case Some(v): Some(f(v));
    };
  }

  public static function newOption&lt;A&gt;(arg: A): Option&lt;A&gt; {
    return if (arg != null) Some(arg) else None;
  }
}
</code></pre>

<p>こんな感じに使う。</p>

<pre><code>import haxe.ds.Option;
using OptionOp;

var x = 123.newOption(); // Scala の Option(123) 的な。
x.map(function(v) { return v * 2; }); // Scala の x.map(_ * 2) 的な。
</code></pre>

<p>他にもいろいろ追加したのが<a href="https://gist.github.com/tkawachi/7208040">こちら</a>。</p>

<p>関数リテラル書くのに毎度 <code>function</code> と書くのは長いが、まあまあ快適に書ける。
コンパイルするとこんな感じになる。</p>

<pre><code>var x = OptionOp.newOption(123);
OptionOp.map(x,function(v) {
        return v * 2;
});    
</code></pre>

<p>「えー。関数の呼び出しが多くて遅そう」という人は <code>inline</code> 化することもできる。
<code>map()</code>, <code>newOption()</code> の定義を <code>public static inline function ...</code> とするとこんな感じの出力に変わる。</p>

<pre><code>var x;
x = haxe.ds.Option.Some(123);
switch(x[1]) {
case 1:
        haxe.ds.Option.None;
        break;
case 0:
        var v = x[2];
        haxe.ds.Option.Some(v * 2);
        break;
}
</code></pre>

<p><code>Some()</code> 関数の呼び出しは残っているものの、 <code>map</code> 関数とその第二引き数で渡した関数の呼び出しは展開された。
これくらいなら速度的にも許容出来る人が多いんじゃない？
読みにくいから僕は inline 化しないけど。</p>

<p>Haxe でどうすればいいのかなと思っているのは Scala の for に相当するもの。
複数の Option があるとき全てが存在するときに何かをするには、 Scala の for を使えば</p>

<pre><code>for (v1 &lt;- opt1; v2 &lt;- opt2) yield { v1 と v2 の計算 }
</code></pre>

<p>みたいに書けるのだが、現在の自分の Haxe 知識レベルだと次のようになる。</p>

<pre><code>opt1.flatMap(function(v1) {
    return opt2.map(function(v2) { return v1 と v2 の計算 });
});
</code></pre>

<p>なんか上手い書き方無いかなあ。
<a href="https://github.com/sledorze/monax">monax</a> 使えばうまくかけるんだろうか？</p>

<h2>まとめ</h2>

<p>JavaScript にアレルギーがあるひとは Haxe 触ると癒されるかも。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[randomForestで重要な説明変数を見つける]]></title>
    <link href="http://tkawachi.github.io/blog/2013/10/14/random-forest-important-variables/"/>
    <updated>2013-10-14T15:33:00+09:00</updated>
    <id>http://tkawachi.github.io/blog/2013/10/14/random-forest-important-variables</id>
    <content type="html"><![CDATA[<p>Random forest といえば決定木を何本ももつアンサンブル学習で高い精度を持つ。
けど、どの説明変数が効いているかは説明が難しいものだと思いこんでいた。
ご近所のデータサイエンティストが R で効いている説明変数を出す方法を教えてくれたのでメモ。</p>

<!-- more -->


<p>ここでは R についてきている iris データセットを使う。
irisはアヤメの種類に関するデータセットで、1936年という大昔に
<a href="http://ja.wikipedia.org/wiki/%E3%83%AD%E3%83%8A%E3%83%AB%E3%83%89%E3%83%BB%E3%83%95%E3%82%A3%E3%83%83%E3%82%B7%E3%83%A3%E3%83%BC">フィッシャー</a>
が論文で使った歴史のあるデータセットでもある。
萼片 (sepal) の大きさ、花弁 (petal) の大きさ、アヤメの種類(species)が対になっている。</p>

<pre><code># iris dataset 読み込み
&gt; data("iris")
&gt; str(iris)
'data.frame':   150 obs. of  5 variables:
 $ Sepal.Length: num  5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ...
 $ Sepal.Width : num  3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ...
 $ Petal.Length: num  1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ...
 $ Petal.Width : num  0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ...
 $ Species     : Factor w/ 3 levels "setosa","versicolor",..: 1 1 1 1 1 1 1 1 1 1 ...
</code></pre>

<p>さて、random forest でアヤメを分類する。
手元にパッケージが入ってなかったのでそこから。</p>

<pre><code>&gt; install.packages("randomForest")
&gt; library(randomForest)
&gt; (fit &lt;- randomForest(Species ~ ., data=iris))

Call:
 randomForest(formula = Species ~ ., data = iris) 
               Type of random forest: classification
                     Number of trees: 500
No. of variables tried at each split: 2

        OOB estimate of  error rate: 4.67%
Confusion matrix:
           setosa versicolor virginica class.error
setosa         50          0         0        0.00
versicolor      0         47         3        0.06
virginica       0          4        46        0.08
</code></pre>

<p><code>fit</code> に random forest で学習したモデルを代入した。</p>

<p>重要な説明変数は <code>importance()</code> で取り出すことができる。</p>

<pre><code>&gt; importance(fit)
             MeanDecreaseGini
Sepal.Length        10.499305
Sepal.Width          2.596317
Petal.Length        43.614641
Petal.Width         42.563816
</code></pre>

<p>どうやら花弁の大きさ(Petal.Length, Petal.Width)がアヤメの種類判定においては重要らしい。
<code>varImpPlot(fit)</code> すると <code>importance(fit)</code> と同じ結果をグラフにしてくれるようだ。</p>

<p><code>importance()</code> では重要な説明変数が分かったが、目的変数に対してどう効くのか、この例でいえば <code>Petal.Length</code> が大きかったらどの種類になりやすいのか、分からない。
<code>partialPlot()</code> を使うと、どう影響するかが分かる。</p>

<pre><code>&gt; partialPlot(fit, iris, Petal.Length, "setosa")
</code></pre>

<p><img src="http://tkawachi.github.io/images/20131014/partialSetosa.png" alt="partialPlot for setosa" /></p>

<pre><code>&gt; partialPlot(fit, iris, Petal.Length, "versicolor")
</code></pre>

<p><img src="http://tkawachi.github.io/images/20131014/partialVersicolor.png" alt="partialPlot for setosa" /></p>

<pre><code>&gt; partialPlot(fit, iris, Petal.Length, "virginica")
</code></pre>

<p><img src="http://tkawachi.github.io/images/20131014/partialVirginica.png" alt="partialPlot for setosa" /></p>

<p>これを見るに、Petal.Length がおおよそ３より小さい時には setosa、
３から５の時には versicolor、５より大きい時には virginica である可能性が高いことが分かる。</p>

<h2>まとめ</h2>

<p>randomForest package の <code>importance()</code>, <code>varImpPlot()</code>, <code>partialPlot()</code> を使えば効いてる説明変数を見つけたり、効いている方向を確認したりできる。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[scala の for]]></title>
    <link href="http://tkawachi.github.io/blog/2013/10/14/scala-for/"/>
    <updated>2013-10-14T11:35:00+09:00</updated>
    <id>http://tkawachi.github.io/blog/2013/10/14/scala-for</id>
    <content type="html"><![CDATA[<p>C や Java と同じように Scala にも for がある。</p>

<p>昔の Java におけるfor 文は、C と同じように <code>for (初期化; 継続条件; カウンタ更新)</code> という形しかなかった。
Java 5.0 で導入された拡張for文（<code>for (型 変数: コレクション)</code>の形）では <code>java.lang.Iterable</code> を実装したオブジェクトならなんでも繰り返しができるようになった。
便利になったなあと思ったのを覚えてる（2004年の話）。</p>

<h2>文法</h2>

<p>Scala で C の for 的なものをやろうとすると</p>

<pre><code>// C では
for (int i = 0; i &lt; 10; i++) { … }
// Scala では
for (i &lt;- 0 until 10) { … }
</code></pre>

<p>となるので「 <code>for (i &lt;- 初期値 until 上限)</code> という固定形なんだー」と最初は思ったのだが、そうではなく <code>for (i &lt;- 初期値.until(上限))</code> であり <code>for (i &lt;- obj)</code> が for 式のパターンである。
ここで<code>初期値.until(上限)</code> は <code>Range</code> 型の値を返す。</p>

<!-- more -->


<p>Scala の言語仕様によると for 式は以下の文法をもつ。</p>

<pre><code>Expr1 ::= ‘for’ (‘(’ Enumerators ‘)’ | ‘{’ Enumerators ‘}’) {nl} [‘yield’] Expr
Enumerators ::= Generator {semi Enumerator}
Enumerator ::= Generator
                | Guard
                | ‘val’ Pattern1 ‘=’ Expr
Generator ::= Pattern1 ‘&lt;-’ Expr [Guard]
Guard ::= ‘if’ PostfixExpr
</code></pre>

<p><code>Enumerator</code> の最後のパターンで <code>‘val’ Pattern1 ‘=’ Expr</code> とあるが、この val は deprecated になったようだ。
（Scala の言語仕様は更新が追いついていないらしく、現時点の最新（2.10.3）の言語仕様書は現時点で存在しない。）</p>

<h2>for式関連メソッド</h2>

<p>Scala の for 式は <code>foreach()</code>, <code>map()</code>, <code>flapMap()</code>, <code>withFilter()</code> が実装されていればなんでも回せる。
全てが必要なわけではなく、用いられるパターンによって必要なメソッドが決まる。</p>

<p><code>foreach()</code> が必要なパターン。 <code>yield</code> なしの時。</p>

<pre><code>for (i &lt;- obj) { … }
// 書き換えると
obj.foreach { case i =&gt; … }
</code></pre>

<p><code>map()</code> が必要なパターン。
Generator がひとつだけで <code>yield</code> で値を返す時。</p>

<pre><code>for (i &lt;- obj) yield { … }
// 書き換えると
obj.map { case i =&gt; … }
</code></pre>

<p><code>flatMap()</code> が必要なパターン。
Generator が複数あり、<code>yield</code> で値を返す時。</p>

<pre><code>for (i &lt;- obj1; j &lt;- obj2) yield { … }
// 書き換えると
obj1.flatMap { case i =&gt; for (j &lt;- obj2) yield { … } }
// obj1 には flatMap が必要。obj2 には map が必要。
</code></pre>

<p><code>withFilter()</code> が必要なパターン。
Guard があるとき。</p>

<pre><code>for (i &lt;- obj1 if i &lt; 0) { … }
// 書き換えると
obj1.withFilter(i =&gt; i &lt; 0).foreach { case i =&gt; … }
</code></pre>

<p>こんな感じで書き換えできるので、本質的には for 式要らないんだと思う。
でも複数の generator を回す時とか、<code>foreach</code> や <code>map</code>, <code>flatMap</code> で書くとネストが深くなってしまうので、for文だとスッキリかけて嬉しいってのはある。</p>

<h2>繰り返し以外の文脈</h2>

<p>必要なメソッドさえ揃っていればいいので、繰り返し以外の文脈で用いることができる。</p>

<p>たとえば <code>scala.Option</code> はオプショナルな値を表す。
値があるかもしれないし無いかもしれないという文脈であり、Javaでいえば null を使いたく場面で使う型である。
<code>Option</code> では for 式に関連するメソッドが、値がある時には関数を実行し、そうでなければ何もせず値なしを結果とするという意味合いで定義されている。</p>

<pre><code>for (i &lt;- Some(1); j &lt;- Some(2)) yield i + j // Some(3)
for (i &lt;- Some(1); j &lt;- None) yield i + j    // None
</code></pre>

<p>上記のように「<code>Option</code> 型の値がいくつかあり、全ての値が存在している時に何かする」というのが for 文で実現できる。</p>

<p>他にも <code>scala.concurrent.Future</code> は将来的に得られる値を表現する型で、
for式関連のメソッドは値が得られた時に関数を実行するように定義されている。</p>

<pre><code>val f1: Future[Int] = …
val f2: Future[Int] = …
val f3: Future[Int] = for (v1 &lt;- f1; v2 &lt;- f2) yield v1 + v2
</code></pre>

<p>ここでは <code>f1</code>, <code>f2</code> の値が将来得られたら <code>v1 + v2</code> を計算するという、コールバックの登録的な意味合いを持っている。</p>

<p><a href="https://github.com/jsuereth/scala-arm">scala-arm</a> では、最後にリソースを開放するという意味合いを for 式関連メソッドに持たせることで、for 式の最後でのリソース解放を実現している。</p>

<h2>まとめ</h2>

<p><code>foreach</code>, <code>map</code>, <code>flatMap</code>, <code>withFilter</code> というメソッドの定義次第で for 式の使い道は無限大。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Covariantとcontravariant]]></title>
    <link href="http://tkawachi.github.io/blog/2013/10/09/covariant-contravariant/"/>
    <updated>2013-10-09T23:06:00+09:00</updated>
    <id>http://tkawachi.github.io/blog/2013/10/09/covariant-contravariant</id>
    <content type="html"><![CDATA[<p>今日 <a href="https://www.coursera.org/course/progfun">Functional Programming Principles in Scala</a> で聞いた話が難しかったのでメモ。</p>

<!-- more -->


<h2>Subtype</h2>

<p>書き方として A &lt;: B と書けば A は B の subtype であることを示す。
A >: B と書けば A は B の supertype、言い換えれば B は A の subtype であることを示す。</p>

<p>Subtype とは何か？というのは Liskov substitution principle というので定義されている。
「A &lt;: B であれば、B型の値に対して出来ることならなんでもA型の値に対して出来る」ということらしい。</p>

<p>クラス階層で言えば、 A &lt;: B というのは A が B の subclass または A == B ってこと。</p>

<p>Subtype の概念はクラス階層にとどまらない。
こんな型が定義されていたら、</p>

<pre><code>class Base
class Derived extends Base
type A = Base =&gt; Derived
type B = Derived =&gt; Base
</code></pre>

<p>A と B の間にクラス階層はないが、B がおける場所には A もおける。
つまり A &lt;: B。
なぜなら</p>

<ul>
<li>B の引き数は Derived で A の引数は Base なので、B の引き数ならなんでも A の引き数として使える</li>
<li>B の戻り値は Base で A の戻り値は Derived なので、A の戻り値ならなんでも B の戻り値として使える</li>
</ul>


<p>から。</p>

<p>関数の場合は一般に A2 &lt;: A1 かつ B1 &lt;: B2 のときに (A1 => B1) &lt;: (A2 => B2) が成り立つ。
理由は上と同じ。</p>

<h2>Variant</h2>

<p>C[T]がパラメータ化された型で A, B が A &lt;: B であるとき、C[A] と C[B] の関係は3パターン。</p>

<ul>
<li>C[A] &lt;: C[B] &mdash; このとき C は covariant（共変）</li>
<li>C[A] >: C[B] &mdash; このとき C は contravarinat（反変）</li>
<li>C[A] と C[B] の間に subtype の関係なし &mdash; このとき C は invariant（不変）。nonvariant とも言うらしい。</li>
</ul>


<p>Scala ではタイプパラメタの前に <code>+</code> とか <code>-</code> とかつけて covariant や contravariant を表現する。何も付けなかったら invariant ね。</p>

<pre><code>class C[+A] // C は covariant
class C[-A] // C は contravariant
class C[A]  // C は invariant
</code></pre>

<p>Function object は covariant, contravariant を使ってる。</p>

<pre><code>trait Function1[-T, +U] {
    def apply(x: T): U
}
</code></pre>

<p><code>A =&gt; B</code> は <code>Function[A, B]</code> と同じ。
で、<code>Function1</code> の T は contravariant, U は invariant ということなので、</p>

<pre><code>class A1
class A2 extends A1
class A3 extends A2
</code></pre>

<p>とあったときに <code>A2 =&gt; A2</code> 型の値は <code>A3 =&gt; A1</code> 型が求められるところならどこでも使える。</p>

<h3>Java の配列</h3>

<p>Java の配列は covariant。</p>

<pre><code>class Base {…}
class Derived1 extends Base {…}
class Derived2 extends Base {…}
</code></pre>

<p>が定義されていてると以下の様なことができる。</p>

<pre><code>Derived1[] a = new Derived1[]{ new Derived1() }
Base[] b = a
b[0] = new Derived2()
Derived1 s = a[0]
</code></pre>

<p>1行目は普通。</p>

<p>2行目は super class である <code>Base</code> の配列に代入しようとしている。
<code>a</code> には <code>Base[]</code> 型がきて欲しいが、Java の配列は covariant なので <code>Base[]</code> が来れる場所には <code>Derived1[]</code> が来ても良い。
なので2行目も通る。</p>

<p>3行目では <code>b[0]</code> に値を代入している。
<code>b[0]</code> の型は <code>Base</code>。
<code>Derived2</code> は <code>Base</code> の subclass なので問題ない。</p>

<p>4行目では <code>Derived1</code> 型の <code>a[0]</code> を別の <code>Derived1</code> 型の変数に代入している。
これも問題無さそう。</p>

<p>という訳でコンパイルは通る。
でも <code>a</code> と <code>b</code> は同じ配列を指していて、3行目で <code>Derived2</code> 型の値に入れ替えてる。
だから <code>a[0]</code> （と<code>b[0]</code>）には <code>Derived2</code> 型の値が入っているはず。
4行目ではそれを <code>Derived1</code> 型の値に代入している。
なにかおかしい。</p>

<p>Javaではコンパイルエラーにはならず、3行目実行時に ArrayStoreException が投げられる。
残念。</p>

<h2>Scala の variance check</h2>

<p>Java の（問題含みの）配列を scala 的に表現すると</p>

<pre><code>class Array[+T] {
    def update(x: T)
}
</code></pre>

<p>となる。
問題は covariant な型パラメータ T がメソッドの引数になっていること。</p>

<p>Scala のコンパイラはこの問題を防ぐために variant check というものを行う。
いろいろ細かいルールはあるそうだが、大まかには以下のとおり。</p>

<ul>
<li>covariant な型パラメータはメソッドの戻り値にしか使っちゃダメ</li>
<li>contravariant な型パラメータはメソッドのパラメタにしか使っちゃダメ</li>
<li>invariant な型パラメータはどこに使ってもいい</li>
</ul>


<p>Function1 を見なおしてみるとルールに合致していることが確認できる。</p>

<pre><code>trait Function1[-T, +U] {
    def apply(x: T): U
}
</code></pre>

<p>contravariant な T はパラメタにきており、covariant な U は戻り値にきている。
問題なし。</p>

<p>Scala では immutable な collection は covariant, mutable な collection は invariant になっているらしい。
きっと Java の例にあるような実行時エラーをコンパイル時に捕まえるにはそうするしか無いんだろうな。</p>

<h2>List を covariant にする話</h2>

<pre><code>trait List[+T] {…}
object Nil extends List[Nothing] {…}
class Cons[T] extends List[T] {…}
</code></pre>

<p>みたいな感じ。</p>

<p><code>Nil</code> のときの <code>T</code> は <code>Nothing</code>。
<code>Nothing</code> は全ての型の subtype（<code>Nothing</code> &lt;: なんでも）。
List は covariant なので <code>List[Nothing]</code> &lt;: <code>List[なんでも]</code> となる。
どの <code>T</code> の <code>List[T]</code> に対しても <code>Nil</code> を使えるので便利。</p>

<p>リストの先頭に要素を追加する <code>prepend</code> メソッドを定義したい。</p>

<pre><code>trait List[+T] {
    def prepend(elem: T): List[T] = new Cons(elem, this)
}
</code></pre>

<p>一見これで良さそうだが、
<code>error: covariant type T occurs in contravariant position in type T of value elem</code>
というコンパイルエラーになる。
Variance check が活躍してる。
たしかに covariant な型パラメータは戻り値にしか使っちゃいけなかったんだ。</p>

<p>正しい定義はこうなる。</p>

<pre><code>trait List[+T] {
    def prepend[U &gt;: T](elem: U): List[U] = new Cons(elem, this)
}
</code></pre>

<p>これは variance check を通る。U は contravariant で引き数のところに使われているから。
戻り値型は <code>List[U]</code> だが U そのものじゃないので contravariant 扱いじゃないんだろう。</p>

<pre><code>class Base
class Derived1 extends Base
class Derived2 extends Base
def f(xs: List[Derived1], x: Derived2) = xs.prepend(x)
</code></pre>

<p>さてこのとき <code>f()</code> の戻り値型はなんだろうか？
<code>prepend()</code> の戻り値なので <code>List[U]</code> 型になるはず。
<code>xs</code> が <code>List[Derived1]</code> 型なので <code>T</code> は <code>Derived1</code> で決まり。</p>

<p><code>U</code>を決めるのに型推論が活躍する。
<code>U</code> は <code>x</code> の型なので <code>Derived2</code> だろうか？
しかし  <code>Derived2</code> だとすると <code>U &gt;: T</code> が満たせない（<code>Derived2</code> は <code>Derived1</code> の supertype ではない）。
というわけで型推論さんは、<code>Derived2</code> と <code>Derived1</code> の共通の親である <code>Base</code> が <code>U</code> だと結論付ける。
したがって <code>f()</code> の戻り値型は <code>List[Base]</code> ということになる。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Scalaのimplicit]]></title>
    <link href="http://tkawachi.github.io/blog/2013/09/28/scala-implicit/"/>
    <updated>2013-09-28T22:16:00+09:00</updated>
    <id>http://tkawachi.github.io/blog/2013/09/28/scala-implicit</id>
    <content type="html"><![CDATA[<p>Scala の implicit のお勉強メモ。</p>

<h2>なぜ implicit を使いたくなるか？</h2>

<p>コード片を見ただけではわからなくなるので、暗黙的な記述はあまり使わない方がいいんじゃないかと個人的に思うのだけど。
それでも便利な使い道があるから使われているみたい。</p>

<p>今自分が知っているところで次のパターンがあるみたい。
他の便利な使い方もきっとあるんじゃなかろうか。</p>

<ul>
<li>既存のクラスを変更せずにメソッドを追加したいとき (pimp my library pattern)。 implicit な関数, implicit なクラスを使う。</li>
<li>型パラメータ情報を実行時に使いたいとき。implicit パラメータをつかう。</li>
<li>共通のインタフェースを持たないクラス群に、共通のインタフェースをあとづけするとき (CONCEPT pattern)。implicit パラメータをつかう。</li>
</ul>


<!-- more -->


<h3>pimp my library pattern</h3>

<p>既存クラスに対してメソッドをあと付けしたいときに使う。
既存クラスが自分のメンテナンスできる範囲で書き換えてOKならこのパターン使わなくていいと思う。
既存クラスがサードパーティライブラリから提供されている場合など、書き換えられない、書き換えるのが面倒ときに使う。</p>

<p>やり方は 2.9 以前の場合は</p>

<ol>
<li>既存クラスをクラスのラッパークラスを定義する</li>
<li>既存クラスからラッパークラスへの暗黙的変換関数を定義する(implicit 関数)</li>
</ol>


<p>(pimp my library pattern)で、2.10 以降の場合は <a href="http://docs.scala-lang.org/overviews/core/implicit-classes.html">implicit class</a> が導入されたのでこれを使うんだと思う。</p>

<p>ここでは <code>Int</code> 型に関数 <code>f1</code> をあと付けしたいとする。</p>

<h4>pimp my libarary pattern</h4>

<p>pimp my library pattern ではまずラッパークラスを定義して、</p>

<pre><code>class MyRichInt(x: Int) {
    def f1 = …
}
</code></pre>

<p>暗黙的変換関数を定義する。</p>

<pre><code>object MyRichInt {
    implicit def intToMyRichInt(x: Int) = new MyRichInt(x)
}
</code></pre>

<p>使う時は暗黙的変換関数を import すれば、メソッドが増えたように感じる。</p>

<pre><code>import MyRichInt._
123.f1 // new MyRichInt(123).f1 相当
</code></pre>

<h4>Implicit class</h4>

<p>Implict class 2.10 から導入された機能。
pimy my library pattern が簡単に書けるようになった感じ。
こんな感じで定義。</p>

<pre><code>object Helpers {
    implicit class IntWithF(x: Int) {
        def f1 = …
    }
}
</code></pre>

<p>使う時は import する。
既存クラスに存在しないメンバを呼び出した場合に、暗黙的に変換できるクラスにメンバがあれば、コンパイラさんが変換→呼び出しという風にしてくれる。</p>

<pre><code>import Helpers._
123.f1 // new IntWithF(123).f1 相当
</code></pre>

<p>これでプログラマ的には既存の Int 型には無かったメンバ <code>f1</code> が増えたかのように扱える。</p>

<p>関連する項目として
<a href="http://docs.scala-lang.org/ja/overviews/core/value-classes.html">value class</a>
がある。
これを一緒に使えば暗黙変換するとき <code>new</code> されなくなる（メモリ割り当てされなくなる）ので
使えるときは使うのがいい。
頻繁に使われるものの場合は速くなりそう。</p>

<h3>型パラメータ情報を実行時に使いたいとき</h3>

<p>JVMは型パラメータをコンパイル時に消しちゃうので実行時には型パラメータの情報は使えない。
<code>def f[A] = new A // 間違い</code> とかしたいときに困る。</p>

<p>そんなときは最後の引き数リストに implicit な <code>ClassTag</code> を受け取るようにすればいいみたい。</p>

<pre><code>def f[A](implicit c: ClassTag[A]) = c.runtimeClass.newInstance().asInstanceOf[A]
</code></pre>

<p><code>c</code> 経由でインスタンスを作ったり出来る。
呼び出し時は <code>c</code> を渡す必要はない。
<code>f[Int]</code> などとして呼び出せる。</p>

<h3>CONCEPT pattern</h3>

<p>既存のクラス群が共通インタフェースを持ってたらひとつの関数で同じように処理できるのに、、ってときに使うパターン。
既存のクラスが書き換えられるなら、インタフェースを新規に作って実装しちゃってもいいんじゃないかと思わなくもないけど、アルゴリズムに関連する部分は分けておきたいなんてこともあるのかもしれない。</p>

<p>この共通インタフェースのことを concept っていうらしい。</p>

<p><code>Int</code> と <code>String</code> が両方共 <code>double</code> っていう関数を持っていたら、ステキなアルゴリズム（関数）がかけるのになあ、とする。</p>

<pre><code>trait DoubleConcept[A] {
    // 共通インタフェース
    def double(v: A): A
}
implicit val doubleInt = new DoubleCondept[Int] {
    // Int の double 定義
    def double(v: Int) = v * 2
}
implicit val doubleString = new DoubleConcept[String] {
    // String の double 定義
    def double(v: String) = v + v
}

def suteki[A](v: A)(implicit c: DoubleCondept[A]) = … // c.double(v) を使ったステキアルゴリズム

suteki(123) // suteki(123)(doubleInt) 相当
suteki("ABC") // suteki(ABC)(doubleString) 相当
</code></pre>

<p>型ごとの共通インタフェース実装を implicit val として定義しておいて、 implicit なパラメータリストでそれを暗黙的に渡す。
暗黙的過ぎて難しい。</p>

<p>ともあれ <code>suteki</code> 関数のなかでは <code>Int</code> と <code>String</code> が両方共 <code>double</code> という共通操作を持っているという前提で関数がかける。
<code>suteki</code>関数呼び出し時の <code>v</code> 引き数の型により、<code>c</code> が <code>doubleInt</code> なのか <code>doubleString</code> なのかはコンパイラが選択してくれる。</p>

<h2>雑感</h2>

<p>Scala の implicit は黒魔術。
使いたくなるパターンは多くなさそうなので用途を抑えておけば理解しやすい。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[テストデータのセットアップに trait を使う]]></title>
    <link href="http://tkawachi.github.io/blog/2013/09/23/use-trait-to-setup-test-data/"/>
    <updated>2013-09-23T23:59:00+09:00</updated>
    <id>http://tkawachi.github.io/blog/2013/09/23/use-trait-to-setup-test-data</id>
    <content type="html"><![CDATA[<p>9月半ばから始まった
<a href="https://www.coursera.org/course/progfun">Functional Programming Principles in Scala</a>
を受講している。
課題内のテストの書き方でこうやるのか、というところがあったのでメモ。</p>

<p>テストケース間でデータを共有したいときがある。
たとえば以下の例では <code>data1</code> と <code>data2</code> が共通なので共通化したくなる。</p>

<pre><code>class FooSuite extends FunSuite {
    test("test A") {
        val data1 = new FooData(…)
        val data2 = new FooData(…)
        // tests with data1 and data2
    }

    test("test B") {
        val data1 = new FooData(…)
        val data2 = new FooData(…)
        // another tests with data1 and data2
    }
}
</code></pre>

<p>普通は以下のようにメンバ変数にしたくなると思う。</p>

<pre><code>class FooSuite extends FunSuite {
    val data1 = new FooData(…)
    val data2 = new FooData(…)

    test("test A") {
        // tests with data1 and data2
    }

    test("test B") {
        // another tests with data1 and data2
    }
}
</code></pre>

<p>この方法は少し問題がある。</p>

<ul>
<li><code>new FooData(…)</code> が例外を出した場合に、<code>FooSuite</code> のインスタンス化に失敗するという問題がある</li>
<li><code>FooData</code> が mutable な場合に、前に実行したテストの内容により結果が変わる可能性がある</li>
</ul>


<p>課題のテストケースでは trait を使って以下のようにしていた。</p>

<pre><code>class FooSuite extends FunSuite {
    trait TestData {
        val data1 = new FooData(…)
        val data2 = new FooData(…)
    }

    test("test A") {
        new TestData {
            // tests with data1 and data2
        }
    }

    test("test B") {
        new TestData {
            // another tests with data1 and data2
        }
    }
}
</code></pre>

<p>各テスト内で <code>TestData</code> trait を継承した無名クラスを作り、無名クラスのコンストラクタ内でテストを実行する。
こうすることで <code>new FooData(…)</code> の実行はテスト実行時になり、各テストごとにデータが初期化されるので、上にあげた問題が解消する。</p>

<p><a href="http://www.scalatest.org/user_guide/sharing_fixtures">Sharing fixtures</a> をみると他の方法もいろいろある。
一番上にある Calling get-fixture methods が一番単純ぽい。
この方法で例を書き換えるとこうなる。</p>

<pre><code>class FooSuite extends FunSuite {
    def fixture = new {
        val data1 = new FooData(…)
        val data2 = new FooData(…)
    }

    test("test A") {
        val f = fixture
        // tests with f.data1 and f.data2
    }

    test("test B") {
        val f = fixture
        import f._
        // another tests with data1 and data2
    }
}
</code></pre>

<p>無名クラスのメンバとしてテストデータを作る。
こっちのほうがインデント少なくていいかも。
<code>import f._</code> すれば <code>f.</code> prefix 要らないしね。
<code>new</code> のあとクラス名無くてもコンパイル通るんだ… 知らなかったよ。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ActiveRecord のモデルを整理する7つのパターン]]></title>
    <link href="http://tkawachi.github.io/blog/2013/09/21/active-model-7-pattern/"/>
    <updated>2013-09-21T21:18:00+09:00</updated>
    <id>http://tkawachi.github.io/blog/2013/09/21/active-model-7-pattern</id>
    <content type="html"><![CDATA[<p><a href="http://blog.codeclimate.com/blog/2012/10/17/7-ways-to-decompose-fat-activerecord-models/">7 Patterns to Refactor Fat ActiveRecord Models</a>
という記事があり、読もう読もうと思いつつ1年くらい経ってしまった。
ようやく読んだので理解した内容を書いておく。
コード例は元記事のもの。</p>

<!-- more -->


<p>Rails で thin controller, fat model を心がけていると、model がマジで激太りしてヤバくなる。
実際に自分が仕事で書いている rails アプリも激太りしててヤバい。
この blog の筆者が作っている <a href="https://codeclimate.com/">CodeClimate</a> で C 判定をもらう程度には肥満体型になっている。</p>

<h2>Mixinに抜き出さない!</h2>

<p>Model が太ってきた時に考えるのは <code>ActiveSupport::Concern</code> を使って感心事を抜き出して、Mixin にすることだと思う。
実際に手元のアプリでも <code>models/concerns/</code> なんていうディレクトリがあったりする。</p>

<p>でもこれはアンチパターン。
Mixin は継承と同じように複雑さを増す。
やってみると、さほど綺麗に分けられないんだよね。
記事では mixin はするな、と書いてある。</p>

<p>ここからがパターンの紹介。</p>

<h2>1. Value object の抽出</h2>

<p><a href="http://en.wikipedia.org/wiki/Value_object">Value object</a>
は値が等しければ等しいとされるようなオブジェクトで、だいたいは immutable。
この value object を抜き出して、関連するロジックを抜き出したクラスに移す。</p>

<p>どんなときに使うか？
属性に強く結びついたロジックがあるとき。</p>

<p>例として挙げられているのは、電話番号、お金など。
CodeClimate には AからF の値をとる <code>Rating</code> value object があるらしい。</p>

<pre><code>class Rating
  include Comparable

  def self.from_cost(cost)
    if cost &lt;= 2
      new("A")
    elsif cost &lt;= 4
      new("B")
    elsif cost &lt;= 8
      new("C")
    elsif cost &lt;= 16
      new("D")
    else
      new("F")
    end
  end

  def initialize(letter)
    @letter = letter
  end

  def better_than?(other)
    self &gt; other
  end

  def &lt;=&gt;(other)
    other.to_s &lt;=&gt; to_s
  end

  def hash
    @letter.hash
  end

  def eql?(other)
    to_s == other.to_s
  end

  def to_s
    @letter.to_s
  end
end
</code></pre>

<p><code>cost</code> から rating を計算するロジックと、比較ロジックがこのクラスに抜き出されている。
<code>#hash</code>, <code>#eql?</code> を定義しておくと、hash key として使うことができる。</p>

<p>ActiveRecord 側。
<code>rating</code> は DB に保存された値から計算される値みたい。</p>

<pre><code>class ConstantSnapshot &lt; ActiveRecord::Base
  # …

  def rating
    @rating ||= Rating.from_cost(cost)
  end
end
</code></pre>

<p>Value object として抜き出せるものがあれば、間違いなく抜き出したほうがいいね。</p>

<h2>2. Service object の抽出</h2>

<p>以下の基準の１つ以上に合致したときには service object の抜き出しを薦めている。</p>

<ul>
<li>アクションが複雑なとき</li>
<li>アクションが複数のモデルに触るとき</li>
<li>アクションが外部サービスとやりとりするとき</li>
<li>アクションがモデルの主な関心事ではないとき</li>
<li>アクションを実行するのにいくつもの方法があるとき（GoFのストラテジパターン）</li>
</ul>


<p>以下の例はユーザ認証を行う service object。</p>

<pre><code>class UserAuthenticator
  def initialize(user)
    @user = user
  end

  def authenticate(unencrypted_password)
    return false unless @user

    if BCrypt::Password.new(@user.password_digest) == unencrypted_password
      @user
    else
      false
    end
  end
end
</code></pre>

<p>ここで <code>user</code> がモデルで、認証というアクションを service object として抽出している。</p>

<p>結局のところ「複雑なメソッド（群）を見つけたら別のクラスにしましょう」ということかな。</p>

<h2>3. Form object の抽出</h2>

<p>フォームの submit で複数のモデルが更新される場合などに使うパターン。
以下の例は <code>User</code> と <code>Company</code> の両方を更新する。</p>

<pre><code>class Signup
  include Virtus

  extend ActiveModel::Naming
  include ActiveModel::Conversion
  include ActiveModel::Validations

  attr_reader :user
  attr_reader :company

  attribute :name, String
  attribute :company_name, String
  attribute :email, String

  validates :email, presence: true
  # … more validations …

  # Forms are never themselves persisted
  def persisted?
    false
  end

  def save
    if valid?
      persist!
      true
    else
      false
    end
  end

private

  def persist!
    @company = Company.create!(name: company_name)
    @user = @company.users.create!(name: name, email: email)
  end
end
</code></pre>

<p><code>Signup</code> クラスは <a href="https://github.com/solnic/virtus">Virtus</a> を使うことで、
ActiveModel のように属性を持つことができる。
<a href="http://api.rubyonrails.org/classes/ActiveModel/Naming.html"><code>ActiveModel::Naming</code></a>と
<a href="http://api.rubyonrails.org/classes/ActiveModel/Conversion.html"><code>ActiveModel::Conversion</code></a>は、つけとくと良いことがあるみたい。
<a href="http://api.rubyonrails.org/classes/ActiveModel/Validations.html"><code>ActiveModel::Validations</code></a> を include することで validation も掛けられる。</p>

<h2>4. Query object の抽出</h2>

<p>複雑なクエリを発行するときは query object を使うといいかも。
放置されたアカウントを探す query object の例。</p>

<pre><code>class AbandonedTrialQuery
  def initialize(relation = Account.scoped)
    @relation = relation
  end

  def find_each(&amp;block)
    @relation.
      where(plan: nil, invites_count: 0).
      find_each(&amp;block)
  end
end
</code></pre>

<p>コンストラクタに渡されているのは <code>ActiveRecord::Relation</code> のインスタンス。
他の条件がついた relation を渡すと、クエリを組み立てることができる。</p>

<pre><code>old_accounts = Account.where("created_at &lt; ?", 1.month.ago)
old_abandoned_trials = AbandonedTrialQuery.new(old_accounts)
</code></pre>

<p>この手のクラスは隔離した状態でのテストを頑張らず、DBにアクセスする形でテストしたほうがいい。</p>

<h2>5. View object の導入</h2>

<p>表示に限ったロジックを書いている場合には、それを抜き出すことを考える。
「もし別のインターフェース（例えば音声コントロールのUI）を実装するときに必要かな？」と考えて No なら view object が向いてる。
以下は Code Climate のドーナツチャートの例。</p>

<pre><code>class DonutChart
  def initialize(snapshot)
    @snapshot = snapshot
  end

  def cache_key
    @snapshot.id.to_s
  end

  def data
    # pull data from @snapshot and turn it into a JSON structure
  end
end
</code></pre>

<h2>6. Policy object の抽出</h2>

<p>読み込みポリシーに特化したオブジェクト。
ビジネスルールをひとつカプセル化する。</p>

<p>Service object に似ているが、service object は操作、 policy object は読み込みを担当。
Query object にも似ているが、query object は SQL 発行、 policy object はメモリ上のドメインモデル読み込みを担当する。</p>

<pre><code>class ActiveUserPolicy
  def initialize(user)
    @user = user
  end

  def active?
    @user.email_confirmed? &amp;&amp;
    @user.last_login_at &gt; 14.days.ago
  end
end
</code></pre>

<p>上記の例は、だれが &ldquo;active?&rdquo; か、という定義を与えている。</p>

<h2>7. Decorator の抽出</h2>

<p>既存の機能の上に機能を足したいときに使うパターン。
たとえばコメント書き込み時に、Facebook wall へもポストするような時に使う。</p>

<pre><code>class FacebookCommentNotifier
  def initialize(comment)
    @comment = comment
  end

  def save
    @comment.save &amp;&amp; post_to_wall
  end

private

  def post_to_wall
    Facebook.post(title: @comment.title, user: @comment.author)
  end
end
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[sbt build definition]]></title>
    <link href="http://tkawachi.github.io/blog/2013/09/16/sbt-build-definition/"/>
    <updated>2013-09-16T22:17:00+09:00</updated>
    <id>http://tkawachi.github.io/blog/2013/09/16/sbt-build-definition</id>
    <content type="html"><![CDATA[<p><a href="http://scalajp.github.io/sbt-getting-started-guide-ja/">始める sbt</a>
を以前読んだときは
<a href="http://scalajp.github.io/sbt-getting-started-guide-ja/basic-def/">.sbt ビルド定義</a>
のところでぐっと難しくなってよくわからなくなった。
今日復習したのでメモ。</p>

<p>最初にまとめ。</p>

<ul>
<li><code>key := value</code> は新しい設定項目を追加する関数のようなもの(<code>Setting[T]</code>)を定義する。</li>
<li><code>Setting[T]</code> の入力は変更されない。</li>
<li><code>.sbt</code> を読み込むと <code>Setting[T]</code> のリストができる。<code>Setting[T]</code> のリストは、依存関係を考慮してソートされた後に適用される。</li>
<li><code>.sbt</code> の空行で区切られた塊は Scala の式。文ではないので <code>val</code>, <code>object</code>, <code>class</code> などは書けない。</li>
<li><code>key := value</code> は <code>key.:=(value)</code> といったメソッド呼び出しを別の書き方にしたもの。</li>
<li>sbtデフォルトの設定項目は
<a href="https://github.com/sbt/sbt/blob/0.13/main/src/main/scala/sbt/Keys.scala"><code>sbt.Keys</code></a>
に定義されている。</li>
<li><code>TaskKey[T]</code> は毎回計算されるキー。</li>
<li>sbtコンソールでアクセスするときは <code>SettingKey[T]</code>, <code>TaskKey[T]</code> などを呼び出す際の第一引き数文字列を使う。</li>
<li>キーの詳細はsbtコンソールから <code>inspect</code> で確認できる。</li>
</ul>


<!-- more -->


<p><code>Setting[T]</code> は、設定を入力に与えると、新しいキーと値のペアを追加したり、既存のキーを新しい値で追加したりといった変換を表す。
変換っていうのは、なにかを入力されたら、それを変更した結果を返すということで、関数みたいな概念で捉えればいいのだろう。
<code>Setting[T]</code>は関数型の精神に則り、入力値は変更しない。</p>

<p><code>.sbt</code> ファイル中の <code>key := value</code> は変換(<code>Setting[T]</code>)を定義している。
たとえば <code>name := "hello"</code> とあれば、キーが<code>name</code>で値が<code>"hello"</code>のペアを追加・上書きする変換を定義する。
<code>T</code> は設定値の型なので、この場合は <code>Setting[String]</code> が定義されたことになる。</p>

<p><code>.sbt</code> ファイルには変換が沢山含まれているので、結果として変換(<code>Setting[T]</code>)のリストができる。</p>

<p><code>Setting[T]</code> のリストに、sbt のデフォルトの設定を入力すると、<code>.sbt</code>ファイルが反映された設定が得られる。
<code>Setting[T]</code>が入力値を変更しないのでsbtのデフォルトの設定は変更されない。</p>

<p><code>.sbt</code> ファイルで <code>name := "hello"</code> と書いたら、<code>name.:=("hello")</code> のこと。
<code>key</code> の型は <code>SettingKey[String]</code> で、 <code>:=</code> は <code>String</code> を引数にとり <code>Setting[String]</code> を返す。
間違った型の値を代入しようとした場合には(例：<code>name := 1</code>)、型チェックでエラーになる。</p>

<p><code>:=</code> メソッドの他にも <code>+=</code> （リストへの要素追加）などがある。</p>

<p>sbtに用意されている設定項目（キー）は
<a href="https://github.com/sbt/sbt/blob/0.13/main/src/main/scala/sbt/Keys.scala"><code>sbt.Keys</code></a>
object に <code>SettingKey[T]</code> 型で定義されている。
<code>.sbt</code>ファイルの内容が評価される時は <code>import sbt.Keys._</code> された状態なので、 <code>sbt.Keys._</code> はパッケージ修飾なしに参照できる。
<a href="https://github.com/sbt/sbt/blob/0.13/main/src/main/scala/sbt/Keys.scala"><code>sbt.Keys</code></a>
は重要。
設定項目を探すときにちょくちょく参照することになる気がする。</p>

<p>たとえば <code>name</code> はこんな感じ。</p>

<pre><code>val name = SettingKey[String]("name", "Project name.", APlusSetting)
</code></pre>

<p>前述のように<code>SettingKey[String]</code>であることがわかる。</p>

<p><a href="https://github.com/sbt/sbt/blob/0.13/main/src/main/scala/sbt/Keys.scala"><code>sbt.Keys</code></a>
には <code>SettingKey[T]</code> 型以外にも、 <code>TaskKey[T]</code>, <code>InputKey[T]</code>, <code>AttributeKey[T]</code> 型の値が定義されてる。
<code>compile</code> のように sbt コンソールから入力するたびに実行してくれないと困るものは
<code>TaskKey[T]</code> として定義されている。
たとえば <code>compile</code> はこんな感じ。</p>

<pre><code>val compile = TaskKey[Analysis]("compile", "Compiles sources.", APlusTask)
</code></pre>

<p><code>SettingKey[T]</code>は一度計算されると結果が保持される。
<code>TaskKey[T]</code>は毎回計算される。
<code>SettingKey[T]</code>は<code>TaskKey[T]</code>に依存できない。</p>

<p><code>InputKey[T]</code>, <code>AttributeKey[T]</code> はまだ知らない。</p>

<p>sbtコンソールから入力するのはキーコンストラクタの第一引き数の文字列。</p>

<pre><code>val scalacOptions = TaskKey[Seq[String]]("scalac-options", "Options for the Scala compiler.")
</code></pre>

<p>とあったら <code>scalac-options</code> がsbtコンソールから入力時に指定する文字列になる。
<code>sbt.Keys</code> に CamelCase で定義されたものは大体コンソール入力時には小文字、ハイフン区切りになっている。</p>

<p>キーに関する情報はsbtコンソールから <code>inspect キー名</code> で得られる。</p>

<p><code>.sbt</code> ファイルの先頭に <code>import</code> 文を複数行書ける。<code>import</code> 文の間は空行をあけなくていい。
他の <code>SettingKey[T]</code> を参照するときに使うのかな。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[akka memo]]></title>
    <link href="http://tkawachi.github.io/blog/2013/09/15/akka-memo/"/>
    <updated>2013-09-15T21:30:00+09:00</updated>
    <id>http://tkawachi.github.io/blog/2013/09/15/akka-memo</id>
    <content type="html"><![CDATA[<p>Scala 2.10 から付いてくる Akka の Actor についてのお勉強メモ。
全然まとまっていないが晒しておく。</p>

<!-- more -->


<h2>概念</h2>

<h3>Actor</h3>

<p><code>akka.actor.Actor</code>。
メッセージを受けて処理をする人。</p>

<h3>Mailbox</h3>

<p>Actorへのメッセージが溜まるところ。</p>

<h3>Supervision</h3>

<p>Actor間の依存関係のこと。
Actorインスタンスはツリー構造になっている。
親が supervisor となる。</p>

<p>Actor が失敗したらどうするかは supervisor の actor が制御する。</p>

<p>親 actor が shutdown したら、その子どもは全て shutdown する。</p>

<p>タスクのまとまり毎にサブツリーを形成するようにすると良いらしい。</p>

<h3>Actor Path</h3>

<p>Actorインスタンスにはツリー構造上の位置を表す文字列がついており、これを actor path と呼ぶ。
<code>/</code>, <code>/user</code>, <code>/user/abc</code> など。</p>

<h3>ActorSystem</h3>

<p><code>akka.actor.ActorSystem</code>。
ツリー全体を管理するもの。
ActorSystemはスレッドを何本も使う重い構造なので沢山作りすぎない。</p>

<h3>Router</h3>

<p>Actor の一種。メッセージを受け取って他の actor に投げる(Routingする)。
投げられる側を routee と呼ぶ。
Routee は router の子どもになる。</p>

<p>以下の様な router が提供されている。どのようにルーティングするかは名前から大体想像がつく。
ロードバランサ的なやつですかね。</p>

<ul>
<li>akka.routing.RoundRobinRouter</li>
<li>akka.routing.RandomRouter</li>
<li>akka.routing.SmallestMailboxRouter</li>
<li>akka.routing.BroadcastRouter</li>
<li>akka.routing.ScatterGatherFirstCompletedRouter</li>
<li>akka.routing.ConsistentHashingRouter</li>
</ul>


<h3>Props</h3>

<p><code>akka.actor.Props</code>。
Actorをインスタンス化する際の設定。
Immutable なので複数の actor をインスタンス化する際に使いまわせる。</p>

<h2>ライフサイクル</h2>

<p>生まれてから死ぬまで。</p>

<p>停止信号を受け取ると以下の手順で止まる。</p>

<ol>
<li>mailbox メッセージの処理をやめる</li>
<li>子どもに停止信号を送る</li>
<li>全ての子どもから停止完了がくるのを待つ</li>
<li>自分自身の停止完了プロセスを実行

<ol>
<li><code>postStop()</code> を呼び出す</li>
<li>mailbox をダンプ</li>
<li><code>DeathWatch</code> に停止完了を知らせる</li>
<li>親に停止完了を知らせる</li>
</ol>
</li>
</ol>


<h3>止めかたのパターン</h3>

<ul>
<li>ActorSystem を shutdown() する。</li>
<li>PoisonPill を actor に送る。通常メッセージと同じように mailbox に送られ、処理されるときに actor が停止する。</li>
<li><code>context.stop(self)</code>, <code>context.stop(child)</code> で止める。</li>
</ul>


<h3>殺しかた</h3>

<ul>
<li>Kill を送ると即座に死ぬ</li>
</ul>


<h3>問題が起きたときの判断</h3>

<p>以下のいずれか。</p>

<ul>
<li>Resume</li>
<li>Restart</li>
<li>Terminate</li>
<li>Escalate</li>
</ul>


<h3>Restart</h3>

<ul>
<li>子どもをterminate。自分をterminate。</li>
<li>子どもの mailbox は保持される。 mailbox を破棄したい時は supervisor が terminate, recreate すること。</li>
</ul>


<h3>ストラテジー</h3>

<ul>
<li>one-for-one strategy &mdash; default

<ul>
<li>Restart (defaultDecider)</li>
</ul>
</li>
<li>all-for-one strategy</li>
</ul>


<p><a href="http://doc.akka.io/docs/akka/snapshot/general/supervision.html#supervision-restart">What Restarting Means</a></p>

<p>失敗は３つのカテゴリに分けられる。</p>

<ul>
<li>特定のメッセージを処理する際のプログラムエラー</li>
<li>メッセージを処理する際に使われる外部リソースの一時的なエラー</li>
<li>Actorの内部状態が壊れた</li>
</ul>


<p>内部状態が壊れたら内部状態を破棄しなければならない。Supervisorや他の子どもが壊れた内部状態の影響を受けなければ、restartするのがベスト。
Restartの際には内部的に新しい Actor がインスタンス化され、ActorRefの参照しているものが切り替わる。
ActorRef の存在意義のひとつは、この切り替え。</p>

<p>Actorが内部で作った子 Actor の ActorRef を外部に保持していると、
Actor restart 時に無効な参照になる。</p>

<p>ガーディアン直下の actor に対応する ActorRef は ActorSystem 終了時まで有効だろうと思う。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ScalaTestでMockito]]></title>
    <link href="http://tkawachi.github.io/blog/2013/08/26/mockito-scala/"/>
    <updated>2013-08-26T10:14:00+09:00</updated>
    <id>http://tkawachi.github.io/blog/2013/08/26/mockito-scala</id>
    <content type="html"><![CDATA[<p>ScalaTestでMockitoを使うためのお勉強ノート</p>

<h2>Setup</h2>

<p><code>build.sbt</code> に追加。</p>

<pre><code>libraryDependencies ++= Seq(
  "org.scalatest" %% "scalatest" % "1.9.1" % "test",
  "org.mockito" % "mockito-core" % "1.9.5" % "test"
)
</code></pre>

<p>テストで <code>MockitoSugar</code> を mixin し、以下の import 行を追加。</p>

<pre><code>import org.mockito.Matchers._
import org.mockito.Mockito._
</code></pre>

<h2>Mock作成</h2>

<pre><code>// ClassToMock のモックを作成
val m = mock[ClassToMock]
</code></pre>

<p>作ったモックはデフォルトで全メソッドコールに対して <code>null</code> を返す。
メソッドの戻り値として<code>null</code>ではなくモックを返したい時は次のようにする。</p>

<pre><code>// メソッド呼び出しでモックを返すモック
mock[ClassToMock](RETURNS_MOCKS)
// 返されたモックもモックを返すモック
mock[ClassToMock](RETURNS_DEEP_STUBS)
</code></pre>

<h2>引数に応じて戻り値を変える</h2>

<p><code>when(メソッド呼び出し).thenReturn(戻り値)</code> で登録する。
メソッド呼び出し部の引き数には <code>any</code> で任意の型の任意の値に、<code>anyString</code>, <code>anyBoolean</code>, <code>anyByte</code>, <code>anyChar</code>などで基本的な型の任意の値に <code>anyVararg</code> で任意の可変引き数にマッチさせることができる。</p>

<pre><code>// m.method1(何か) が呼ばれたら 10 を返す
when(m.method1(any)).thenReturn(10)
</code></pre>

<p>引数が２つ以上あり、いずれかで <code>any</code> などのマッチャーを使った場合には、他の引き数もマッチャーにする必要がある。
オブジェクトが等しいことを示すマッチャーは <code>eq(obj)</code> で作れる。</p>

<p>後から登録したものが先にマッチするので、条件のゆるいもの（マッチ範囲が広いもの）を先に書く。</p>

<h3>１回目、２回目で違う値を返す</h3>

<p><code>thenReturn()</code> の可変引き数版を使う</p>

<pre><code>// 最初は 10, 次は 20, それ以降はずっと 30 を返す
when(m.method1()).thenReturn(10, 20, 30)
</code></pre>

<h2>例外を起こす</h2>

<pre><code>// method1() が呼ばれたら例外を起こす
when(m.method1()).thenThrow(new RuntimeException("Gau gau"))
</code></pre>

<p><code>thenReturn</code> と同じように１回目、２回目で違う例外を起こすことも可能。
むしろ <code>thenReturn</code> と組み合わせることができる。</p>

<pre><code>when(m.method1())
  .thenReturn(10, 20) // １回目は10, ２回目は20を返す
  .thenThrow(new FooException, new BarException) // ３、４回目は例外
  .thenReturn(30) // ５回目以降は30を返す
</code></pre>

<h2>オブジェクトの一部をモックする(spy)</h2>

<p><code>mock[ClassToMock]</code> はフルのモック。一部だけモックしたい場合はこっち。<code>spy</code>と呼ぶ。</p>

<pre><code>// obj は普通のオブジェクト
val s = spy(obj)
// s.method1(何か) が呼ばれたら obj の実装を使わずに 10 を返す。
doReturn(10).when(s).method1(any[ClassOfArg])
</code></pre>

<p><code>thenReturn</code> が <code>doReturn</code> になって順番が代わり、メソッド呼び出しも <code>when</code> の外に出す。
<code>thenReturn</code>の書き方では実際のメソッドが呼ばれるので、呼ばれては困るときにこちらの書き方をする。</p>

<p>この記法の場合は <code>any</code> を使うときに型を指定しなければならなかった
（理由はわかってない）。</p>

<h2>メソッドが呼び出されたことを確認する(verify)</h2>

<p><code>when()</code>, <code>thenReturn()</code>, <code>doReturn()</code> などは関数呼び出しの前に用意する。
用意したものがテスト中で呼び出されなくても問題ない。</p>

<p>呼び出されたことを確認するには <code>verify()</code> を使う。</p>

<pre><code>// テストを実行
m.method1(123);
// method1() が何らかの整数引き数で呼び出されたことを確認
verify(m).method1(anyInt);
</code></pre>

<p>複数回呼び出されたことを確認するときは、<code>verify()</code>の第二引き数で回数指定をする。</p>

<pre><code>// 2回呼び出されたことを確認
verify(m, times(2)).method1(anyInt)
// 少なくとも2回
verify(m, atLeast(2)).method1(anyInt)
// 多くとも3回
verify(m, atMost(3)).method1(anyInt)
</code></pre>

<h3>呼び出されてないことを確認する</h3>

<p><code>never</code> を使う。</p>

<pre><code>// 一度も呼ばれてないことを確認
verify(m, never).method1(anyInt)
</code></pre>

<h2>より進んだ使い方</h2>

<p><a href="http://docs.mockito.googlecode.com/hg/latest/org/mockito/Mockito.html">Mockitoのドキュメント</a>
に書いてある。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[「すごい Haskell たのしく学ぼう！」読書 (1)]]></title>
    <link href="http://tkawachi.github.io/blog/2013/06/16/1/"/>
    <updated>2013-06-16T20:49:00+09:00</updated>
    <id>http://tkawachi.github.io/blog/2013/06/16/1</id>
    <content type="html"><![CDATA[<p>「Scala実践プログラミング」を読書したり、Scala 関連の blog を読んでいたりすると、
「HaskellではこうやるのをScalaで実現するには云々」という話が多くて困る。
なぜなら僕はHaskell知らないから。</p>

<p>と開き直ってもしかたがないので Haskell の入門書として評価が高そうな「すごい Haskell たのしく学ぼう！」
を購入した。
Kindle版があるのは素晴らしい。</p>

<p>読書メモを残しておく。今日はイントロを読んだ。</p>

<ul>
<li>Haskell はおもしろい</li>
<li>困ったら freenode #haskell へ (日本語だとどこなんだろう？)</li>
<li>純粋関数型言語で宣言的 (&lt;&ndash;> 命令形言語で手続き的)</li>
<li>副作用なし。参照透明性(同じ引数で関数が呼ばれたら同じ値を返す)。</li>
<li>遅延評価</li>
<li>静的型付けで型推論あり。</li>
<li>言語仕様は TheHaskellReport。最新は2010年。</li>
<li>GHC: コンパイラと対話プログラム(ghci)</li>
<li>ghci のコマンド

<ul>
<li>:q &mdash; 終了</li>
<li>:l foo &mdash; foo.hs のロード</li>
<li>:r &mdash; 最後の :l を再実行</li>
</ul>
</li>
<li>ワークフロー

<ol>
<li>foo.hs を作る</li>
<li>:l foo</li>
<li>foo.hs を編集</li>
<li>:r (以下繰り返し)</li>
</ol>
</li>
</ul>


<p>語り口が柔らかで読みやすい。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Octopress で universal analytics へ切り替え]]></title>
    <link href="http://tkawachi.github.io/blog/2013/06/15/1/"/>
    <updated>2013-06-15T21:35:00+09:00</updated>
    <id>http://tkawachi.github.io/blog/2013/06/15/1</id>
    <content type="html"><![CDATA[<p>この blog では google analytics を入れているが、それを今年の春に公開された
<a href="https://support.google.com/analytics/answer/2790010?hl=ja">universal analytics</a>
に切り替えてみた。
なんか色々できることが増えてるみたい。</p>

<p>まず、既存のプロパティをそのまま universal analytics へ移行することは出来ない。
Google Analytics のプロパティを新しく作る必要があった。</p>

<!-- more -->


<p>次にするのは JavaScript スニペットの更新。
今までは <code>ga.js</code> を読み込んでいたが、これが <code>analytics.js</code> に変わる。
イベント送信時の syntax も変わる。</p>

<p>この blog で使っている octopress では、<code>analytics.js</code> に対応していない。
<a href="https://github.com/tkawachi/tkawachi.github.com/commit/2ecc6d3f6548de37e6ba02d0d8ac1134dc3778c0">こんな感じ</a>
でちょいちょいと変更したところ無事に動いているようだ。</p>

<p>セッションのタイムアウト時間が設定できるようになっていたり、できることが増えているようだが、まだ良くわかっていない。
ともあれ切り替えは無事にできた。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[s3:ListBucketVersions]]></title>
    <link href="http://tkawachi.github.io/blog/2013/06/13/1/"/>
    <updated>2013-06-13T16:44:00+09:00</updated>
    <id>http://tkawachi.github.io/blog/2013/06/13/1</id>
    <content type="html"><![CDATA[<p>IAM でアクセス権限を管理するのは面倒だ。
まず権限の種類が覚えきれない。</p>

<p>s3:ListBucket を許可していたのに、
Ruby の AWS SDK で
<a href="http://docs.aws.amazon.com/AWSRubySDK/latest/AWS/S3/Bucket.html#empty%3F-instance_method"><code>AWS::S3::Bucket#empty?</code></a>
にて例外が発生した。</p>

<!-- more -->


<p>調べてみたら、バージョン付けされたオブジェクトも含めて list して、空かどうか確認しているようだ。
この場合は s3:ListBucket ではなく s3:ListBucketVersions を許可しなければならないようだ。
たぶん IAM で権限管理を細かく管理している人はほとんどいないんじゃないかな。
めんどうだもの。</p>

<p>参考</p>

<ul>
<li><a href="http://docs.aws.amazon.com/AmazonS3/latest/dev/UsingIAMPolicies.html">Using IAM Policies</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[型境界]]></title>
    <link href="http://tkawachi.github.io/blog/2013/06/12/1/"/>
    <updated>2013-06-12T21:36:00+09:00</updated>
    <id>http://tkawachi.github.io/blog/2013/06/12/1</id>
    <content type="html"><![CDATA[<p>Type parameter の境界指定方法。</p>

<ul>
<li>upper bound (<code>A &lt;: U</code>): A は U またはその子クラス</li>
<li>lower bound (<code>A &gt;: L</code>): A は L またはその親クラス</li>
</ul>


<p>両方指定する(<code>A &gt;: L &lt;: U</code>)ことも可能。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[loan pattern]]></title>
    <link href="http://tkawachi.github.io/blog/2013/06/11/1/"/>
    <updated>2013-06-11T22:07:00+09:00</updated>
    <id>http://tkawachi.github.io/blog/2013/06/11/1</id>
    <content type="html"><![CDATA[<p>最近仕事で scala を書いてまして、
Java 延長線上として使う分には全く問題ないのだが、
scala ぽいこととなるとかなり怪しい。
なので初歩から少しずつ勉強して、その様子を晒しておくことにする。</p>

<p>今日は loan pattern。
リソース解放を忘れずに行うためのパターン。
C++ では RAII, golang では defer を使う場面で使うやつ。</p>

<!-- more -->


<p>以下、基本形。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'>  <span class="k">def</span> <span class="n">using</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">R</span> <span class="k">&lt;:</span> <span class="o">{</span><span class="kt">def</span> <span class="kt">close</span><span class="o">()}](</span><span class="n">r</span><span class="k">:</span> <span class="kt">R</span><span class="o">)(</span><span class="n">f</span><span class="k">:</span> <span class="kt">R</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
</span><span class='line'>    <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">f</span><span class="o">(</span><span class="n">r</span><span class="o">)</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">r</span><span class="o">.</span><span class="n">close</span><span class="o">()</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 使いかた</span>
</span><span class='line'>  <span class="n">using</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileWriter</span><span class="o">(</span><span class="s">&quot;xyz&quot;</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>    <span class="o">(</span><span class="n">f</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="c1">// f に対する操作</span>
</span><span class='line'>  <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>ポイント</p>

<ul>
<li>parameterized type の R には structural type で upper bound を指定する(<code>R &lt;: {def close()}</code>)。
これにより R には <code>close()</code> メソッドを持つ任意の型を受け付けられる。
Structural typing は scala で duck typing できる機能。便利。
R の upper bound に trait や class を指定すると継承関係がある型しか使えないので
汎用性が下がり残念な気持ちになる。注意。</li>
</ul>


<p>それにしても名前が覚えづらい。</p>

<p>参考</p>

<ul>
<li><a href="http://www.ne.jp/asahi/hishidama/home/tech/scala/sample/using.html">Scala using（ローンパターン）</a></li>
</ul>


<hr />

<p>2013/6/12: parameterized type R の指定には upper bound で structural type を指定するのではなく、 view bound (<code>R &lt;% {def close()}</code>) で structural type を指定する方が汎用性が高い。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RailsでTypeScript、再び]]></title>
    <link href="http://tkawachi.github.io/blog/2013/04/25/typescript-and-rails-again/"/>
    <updated>2013-04-25T23:22:00+09:00</updated>
    <id>http://tkawachi.github.io/blog/2013/04/25/typescript-and-rails-again</id>
    <content type="html"><![CDATA[<p>Google で typescript rails と検索すると去年12月に書いた「<a href="http://tkawachi.github.io/blog/2012/12/09/trying-typescript-rails-out/">Rails で TypeScript を動かそうとして失敗した記録</a>」というエントリが2番目に出てくる日々が続いている。
「TypeScriptをRailsで使いたい」と思った人たちは、検索結果を見て、ああ動かないのかと思うのだろう。</p>

<p>あれから状況は少しだけ改善した。
typescript-rails gem で <code>/// &lt;reference&gt;</code> が一部使えるようになった。
というか使えるようにする <a href="https://github.com/klaustopher/typescript-rails/pull/6">patch</a> を出した。</p>

<p>この patch により、<code>node</code> コマンドをインストールしてあることが前提になったので注意されたし。</p>

<p>サンプルを作ろうと思い
<a href="https://github.com/tkawachi/typescript-rails-sample/blob/051838b7/app/assets/javascripts/test.js.ts.erb">test.js.ts.erb</a>
を書いてみた。
<code>.js.ts</code> ファイルや <code>.d.ts</code> ファイルを参照できるようになっていることがわかると思う。
サンプル内でやっているように <code>jquery.d.ts</code> を参照して、 jQuery も使えるようになった。</p>

<p>一方で以下の問題が残っている。
TypeScript compiler に渡る際に違うディレクトリにコピーされるため、参照先を絶対パスで指定している。そのため <code>.erb</code> suffix を付ける必要がある。
また参照先の拡張子が <code>.js.ts</code>, <code>.d.ts</code> ならば大丈夫だが <code>.js.ts.erb</code> の場合、compiler が参照してくれない。</p>

<p>これらの問題を解消しないとちょっと本格利用はできないかなあ。
また時間がとれたらなんとかしたい。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使わないと損なバックエンドサービス]]></title>
    <link href="http://tkawachi.github.io/blog/2013/02/17/backend-services/"/>
    <updated>2013-02-17T18:47:00+09:00</updated>
    <id>http://tkawachi.github.io/blog/2013/02/17/backend-services</id>
    <content type="html"><![CDATA[<p><a href="http://slash7.com/company/">slash7</a> の Thomas Fuchs さんが自分たちのサービス
<a href="http://mir.aculo.us/2013/02/16/running-a-saas-here-are-some-services-youll-find-useful/">Freckle で使っている有償サービス群を紹介</a>している。
小さいチームでは自分のビジネスのコアに集中し、それ以外の部分に力を分散させるべからずというのはまさにその通り。</p>

<p>紹介されていたサービスは以下のとおり。
知らないサービスもいくつかあるなあ。</p>

<!-- more -->


<ul>
<li><a href="http://beta.travis-ci.com/">Travis Pro</a>
(<a href="http://about.travis-ci.org/docs/user/travis-pro/">ドキュメント</a>)
CI(継続的インテグレーション)サービス。
Open source 製品は Pro じゃない方が使える。</li>
<li><a href="http://newrelic.com/">NewRelic</a> 性能監視サービス。これは僕も使ってる。</li>
<li><a href="https://postmarkapp.com/">Postmark</a> メール配送サービス。メールを送るならマスト、らしい。メール受信もできるらしい。
同種のサービスは<a href="http://socialcompare.com/en/comparison/transactional-emailing-providers-mailjet-sendgrid-critsend">沢山ある</a>。
例えば<a href="http://sendgrid.com/">SendGrid</a>。</li>
<li><a href="https://www.honeybadger.io/">Honeybadger</a> Rails用のエラー管理ツール。
僕は <a href="http://www.exceptional.io/">Exceptional.io</a> を使っている。</li>
<li><a href="http://docraptor.com/">DocRaptor</a> HTML から PDF を生成するツール。請求書ダウンロードで使っているらしい。</li>
<li><a href="https://logentries.com/">Logentries</a> Log管理サービス。
複数サーバのログが同じ時系列で見える。検索可能。
同種のサービスに <a href="http://loggly.com/">Loggly</a> がある。</li>
<li><a href="http://www.dome9.com/">Dome9</a> ファイアウォール設定サービス。
iptablesでごにょごにょしなくてもいいらしい。</li>
<li><a href="http://webmon.com/">Webmon</a> と <a href="https://www.pingdom.com/">pingdom</a>。
サービスの可用性を測るサービス。
pingdom のほうは<a href="http://status.letsfreckle.com/">こういうステータス表示</a>もできるようだ。</li>
<li><a href="https://deadmanssnitch.com/">Dead Man’s Snitch</a> Cron が走ってなかったらメールしてくれるサービス。</li>
<li><a href="http://www.pagerduty.com/">PagerDuty</a> アラートを集めてメールなどで通知するサービス。
同種のサービスに<a href="http://www.opsgenie.com/">OpsGenie</a>。</li>
<li><a href="https://www.tinfoilsecurity.com/">Tinfoil</a> と <a href="https://www.trustwave.com/">Trustwave</a>。
セキュリティをチェックし、脆弱性がある場合に教えてくれるサービス。</li>
<li><a href="http://www.kissmetrics.com/">KISSmetrics</a>。メトリックスおよびイベントトラッキングサービス。</li>
<li><a href="http://customer.io/">Customer.io</a> お知らせメール送信サービス。最近きてない人だけに送るなんてことができる。</li>
</ul>


<p>すでに適正価格でやってくれるサービスがある場合、それを使わないで自分で作るのは馬鹿げています。使えるものは使いましょう。</p>
]]></content>
  </entry>
  
</feed>
