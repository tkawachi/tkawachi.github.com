<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[tkawachi Blog]]></title>
  <link href="http://tkawachi.github.io/atom.xml" rel="self"/>
  <link href="http://tkawachi.github.io/"/>
  <updated>2013-10-14T13:29:06+09:00</updated>
  <id>http://tkawachi.github.io/</id>
  <author>
    <name><![CDATA[KAWACHI Takashi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[scala の for]]></title>
    <link href="http://tkawachi.github.io/blog/2013/10/14/scala-for/"/>
    <updated>2013-10-14T11:35:00+09:00</updated>
    <id>http://tkawachi.github.io/blog/2013/10/14/scala-for</id>
    <content type="html"><![CDATA[<p>C や Java と同じように Scala にも for がある。</p>

<p>昔の Java におけるfor 文は、C と同じように <code>for (初期化; 継続条件; カウンタ更新)</code> という形しかなかった。
Java 5.0 で導入された拡張for文（<code>for (型 変数: コレクション)</code>の形）では <code>java.lang.Iterable</code> を実装したオブジェクトならなんでも繰り返しができるようになった。
便利になったなあと思ったのを覚えてる（2004年の話）。</p>

<h2>文法</h2>

<p>Scala で C の for 的なものをやろうとすると</p>

<pre><code>// C では
for (int i = 0; i &lt; 10; i++) { … }
// Scala では
for (i &lt;- 0 until 10) { … }
</code></pre>

<p>となるので「 <code>for (i &lt;- 初期値 until 上限)</code> という固定形なんだー」と最初は思ったのだが、そうではなく <code>for (i &lt;- 初期値.until(上限))</code> であり <code>for (i &lt;- obj)</code> が for 式のパターンである。
ここで<code>初期値.until(上限)</code> は <code>Range</code> 型の値を返す。</p>

<!-- more -->


<p>Scala の言語仕様によると for 式は以下の文法をもつ。</p>

<pre><code>Expr1 ::= ‘for’ (‘(’ Enumerators ‘)’ | ‘{’ Enumerators ‘}’) {nl} [‘yield’] Expr
Enumerators ::= Generator {semi Enumerator}
Enumerator ::= Generato
                | Guard
                | ‘val’ Pattern1 ‘=’ Expr
Generator ::= Pattern1 ‘&lt;-’ Expr [Guard]
Guard ::= ‘if’ PostfixExpr
</code></pre>

<p><code>Enumerator</code> の最後のパターンで <code>‘val’ Pattern1 ‘=’ Expr</code> とあるが、この val は deprecated になったようだ。
（Scala の言語仕様は更新が追いついていないらしく、現時点の最新（2.10.3）の言語仕様書は現時点で存在しない。）</p>

<h2>for式関連メソッド</h2>

<p>Scala の for 式は <code>foreach()</code>, <code>map()</code>, <code>flapMap()</code>, <code>withFilter()</code> が実装されていればなんでも回せる。
全てが必要なわけではなく、用いられるパターンによって必要なメソッドが決まる。</p>

<p><code>foreach()</code> が必要なパターン。 <code>yield</code> なしの時。</p>

<pre><code>for (i &lt;- obj) { … }
// 書き換えると
obj.foreach { case i =&gt; … }
</code></pre>

<p><code>map()</code> が必要なパターン。
Generator がひとつだけで <code>yield</code> で値を返す時。</p>

<pre><code>for (i &lt;- obj) yield { … }
// 書き換えると
obj.map { case i =&gt; … }
</code></pre>

<p><code>flatMap()</code> が必要なパターン。
Generator が複数あり、<code>yield</code> で値を返す時。</p>

<pre><code>for (i &lt;- obj1; j &lt;- obj2) yield { … }
// 書き換えると
obj1.flatMap { case i =&gt; for (j &lt;- obj2) yield { … } }
// obj1 には flatMap が必要。obj2 には map が必要。
</code></pre>

<p><code>withFilter()</code> が必要なパターン。
Guard があるとき。</p>

<pre><code>for (i &lt;- obj1 if i &lt; 0) { … }
// 書き換えると
obj1.withFilter(i =&gt; i &lt; 0).foreach { case i =&gt; … }
</code></pre>

<p>こんな感じで書き換えできるので、本質的には for 式要らないんだと思う。
でも複数の generator を回す時とか、<code>foreach</code> や <code>map</code>, <code>flatMap</code> で書くとネストが深くなってしまうので、for文だとスッキリかけて嬉しいってのはある。</p>

<h2>繰り返し以外の文脈</h2>

<p>必要なメソッドさえ揃っていればいいので、繰り返し以外の文脈で用いることができる。</p>

<p>たとえば <code>scala.Option</code> はオプショナルな値を表す。
値があるかもしれないし無いかもしれないという文脈で、Javaで null を使いたく場面で使う。
<code>Option</code> では for 式に関連するメソッドが、値がある時には関数を実行し、そうでなければ何もせず値なしを結果とするという意味合いで定義されている。</p>

<pre><code>for (i &lt;- Some(1); j &lt;- Some(2)) yield i + j // Some(3)
for (i &lt;- Some(1); j &lt;- None) yield i + j    // None
</code></pre>

<p>上記のように「<code>Option</code> 型の値がいくつかあり、全ての値が存在している時に何かする」というのが for 文で実現できる。</p>

<p>他にも <code>scala.concurrent.Future</code> は将来的に得られる値を表現する型で、
for式関連のメソッドは値が得られた時に関数を実行するように定義されている。</p>

<pre><code>val f1: Future[Int] = …
val f2: Future[Int] = …
val f3: Future[Int] = for (v1 &lt;- f1; v2 &lt;- f2) yield v1 + v2
</code></pre>

<p>ここでは <code>f1</code>, <code>f2</code> の値が将来得られたら <code>v1 + v2</code> を計算するという、コールバックの登録的な意味合いを持っている。</p>

<p><a href="https://github.com/jsuereth/scala-arm">scala-arm</a> では、最後にリソースを開放するという意味合いを for 式関連メソッドに持たせることで、for 式の最後でのリソース解放を実現している。</p>

<h2>まとめ</h2>

<p><code>foreach</code>, <code>map</code>, <code>flatMap</code>, <code>withFilter</code> というメソッドの定義次第で for 式の使い道は無限大。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Covariantとcontravariant]]></title>
    <link href="http://tkawachi.github.io/blog/2013/10/09/covariant-contravariant/"/>
    <updated>2013-10-09T23:06:00+09:00</updated>
    <id>http://tkawachi.github.io/blog/2013/10/09/covariant-contravariant</id>
    <content type="html"><![CDATA[<p>今日 <a href="https://www.coursera.org/course/progfun">Functional Programming Principles in Scala</a> で聞いた話が難しかったのでメモ。</p>

<!-- more -->


<h2>Subtype</h2>

<p>書き方として A &lt;: B と書けば A は B の subtype であることを示す。
A >: B と書けば A は B の supertype、言い換えれば B は A の subtype であることを示す。</p>

<p>Subtype とは何か？というのは Liskov substitution principle というので定義されている。
「A &lt;: B であれば、B型の値に対して出来ることならなんでもA型の値に対して出来る」ということらしい。</p>

<p>クラス階層で言えば、 A &lt;: B というのは A が B の subclass または A == B ってこと。</p>

<p>Subtype の概念はクラス階層にとどまらない。
こんな型が定義されていたら、</p>

<pre><code>class Base
class Derived extends Base
type A = Base =&gt; Derived
type B = Derived =&gt; Base
</code></pre>

<p>A と B の間にクラス階層はないが、B がおける場所には A もおける。
つまり A &lt;: B。
なぜなら</p>

<ul>
<li>B の引き数は Derived で A の引数は Base なので、B の引き数ならなんでも A の引き数として使える</li>
<li>B の戻り値は Base で A の戻り値は Derived なので、A の戻り値ならなんでも B の戻り値として使える</li>
</ul>


<p>から。</p>

<p>関数の場合は一般に A2 &lt;: A1 かつ B1 &lt;: B2 のときに (A1 => B1) &lt;: (A2 => B2) が成り立つ。
理由は上と同じ。</p>

<h2>Variant</h2>

<p>C[T]がパラメータ化された型で A, B が A &lt;: B であるとき、C[A] と C[B] の関係は3パターン。</p>

<ul>
<li>C[A] &lt;: C[B] &mdash; このとき C は covariant（共変）</li>
<li>C[A] >: C[B] &mdash; このとき C は contravarinat（反変）</li>
<li>C[A] と C[B] の間に subtype の関係なし &mdash; このとき C は invariant（不変）。nonvariant とも言うらしい。</li>
</ul>


<p>Scala ではタイプパラメタの前に <code>+</code> とか <code>-</code> とかつけて covariant や contravariant を表現する。何も付けなかったら invariant ね。</p>

<pre><code>class C[+A] // C は covariant
class C[-A] // C は contravariant
class C[A]  // C は invariant
</code></pre>

<p>Function object は covariant, contravariant を使ってる。</p>

<pre><code>trait Function1[-T, +U] {
    def apply(x: T): U
}
</code></pre>

<p><code>A =&gt; B</code> は <code>Function[A, B]</code> と同じ。
で、<code>Function1</code> の T は contravariant, U は invariant ということなので、</p>

<pre><code>class A1
class A2 extends A1
class A3 extends A2
</code></pre>

<p>とあったときに <code>A2 =&gt; A2</code> 型の値は <code>A3 =&gt; A1</code> 型が求められるところならどこでも使える。</p>

<h3>Java の配列</h3>

<p>Java の配列は covariant。</p>

<pre><code>class Base {…}
class Derived1 extends Base {…}
class Derived2 extends Base {…}
</code></pre>

<p>が定義されていてると以下の様なことができる。</p>

<pre><code>Derived1[] a = new Derived1[]{ new Derived1() }
Base[] b = a
b[0] = new Derived2()
Derived1 s = a[0]
</code></pre>

<p>1行目は普通。</p>

<p>2行目は super class である <code>Base</code> の配列に代入しようとしている。
<code>a</code> には <code>Base[]</code> 型がきて欲しいが、Java の配列は covariant なので <code>Base[]</code> が来れる場所には <code>Derived1[]</code> が来ても良い。
なので2行目も通る。</p>

<p>3行目では <code>b[0]</code> に値を代入している。
<code>b[0]</code> の型は <code>Base</code>。
<code>Derived2</code> は <code>Base</code> の subclass なので問題ない。</p>

<p>4行目では <code>Derived1</code> 型の <code>a[0]</code> を別の <code>Derived1</code> 型の変数に代入している。
これも問題無さそう。</p>

<p>という訳でコンパイルは通る。
でも <code>a</code> と <code>b</code> は同じ配列を指していて、3行目で <code>Derived2</code> 型の値に入れ替えてる。
だから <code>a[0]</code> （と<code>b[0]</code>）には <code>Derived2</code> 型の値が入っているはず。
4行目ではそれを <code>Derived1</code> 型の値に代入している。
なにかおかしい。</p>

<p>Javaではコンパイルエラーにはならず、3行目実行時に ArrayStoreException が投げられる。
残念。</p>

<h2>Scala の variance check</h2>

<p>Java の（問題含みの）配列を scala 的に表現すると</p>

<pre><code>class Array[+T] {
    def update(x: T)
}
</code></pre>

<p>となる。
問題は covariant な型パラメータ T がメソッドの引数になっていること。</p>

<p>Scala のコンパイラはこの問題を防ぐために variant check というものを行う。
いろいろ細かいルールはあるそうだが、大まかには以下のとおり。</p>

<ul>
<li>covariant な型パラメータはメソッドの戻り値にしか使っちゃダメ</li>
<li>contravariant な型パラメータはメソッドのパラメタにしか使っちゃダメ</li>
<li>invariant な型パラメータはどこに使ってもいい</li>
</ul>


<p>Function1 を見なおしてみるとルールに合致していることが確認できる。</p>

<pre><code>trait Function1[-T, +U] {
    def apply(x: T): U
}
</code></pre>

<p>contravariant な T はパラメタにきており、covariant な U は戻り値にきている。
問題なし。</p>

<p>Scala では immutable な collection は covariant, mutable な collection は invariant になっているらしい。
きっと Java の例にあるような実行時エラーをコンパイル時に捕まえるにはそうするしか無いんだろうな。</p>

<h2>List を covariant にする話</h2>

<pre><code>trait List[+T] {…}
object Nil extends List[Nothing] {…}
class Cons[T] extends List[T] {…}
</code></pre>

<p>みたいな感じ。</p>

<p><code>Nil</code> のときの <code>T</code> は <code>Nothing</code>。
<code>Nothing</code> は全ての型の subtype（<code>Nothing</code> &lt;: なんでも）。
List は covariant なので <code>List[Nothing]</code> &lt;: <code>List[なんでも]</code> となる。
どの <code>T</code> の <code>List[T]</code> に対しても <code>Nil</code> を使えるので便利。</p>

<p>リストの先頭に要素を追加する <code>prepend</code> メソッドを定義したい。</p>

<pre><code>trait List[+T] {
    def prepend(elem: T): List[T] = new Cons(elem, this)
}
</code></pre>

<p>一見これで良さそうだが、
<code>error: covariant type T occurs in contravariant position in type T of value elem</code>
というコンパイルエラーになる。
Variance check が活躍してる。
たしかに covariant な型パラメータは戻り値にしか使っちゃいけなかったんだ。</p>

<p>正しい定義はこうなる。</p>

<pre><code>trait List[+T] {
    def prepend[U &gt;: T](elem: U): List[U] = new Cons(elem, this)
}
</code></pre>

<p>これは variance check を通る。U は contravariant で引き数のところに使われているから。
戻り値型は <code>List[U]</code> だが U そのものじゃないので contravariant 扱いじゃないんだろう。</p>

<pre><code>class Base
class Derived1 extends Base
class Derived2 extends Base
def f(xs: List[Derived1], x: Derived2) = xs.prepend(x)
</code></pre>

<p>さてこのとき <code>f()</code> の戻り値型はなんだろうか？
<code>prepend()</code> の戻り値なので <code>List[U]</code> 型になるはず。
<code>xs</code> が <code>List[Derived1]</code> 型なので <code>T</code> は <code>Derived1</code> で決まり。</p>

<p><code>U</code>を決めるのに型推論が活躍する。
<code>U</code> は <code>x</code> の型なので <code>Derived2</code> だろうか？
しかし  <code>Derived2</code> だとすると <code>U &gt;: T</code> が満たせない（<code>Derived2</code> は <code>Derived1</code> の supertype ではない）。
というわけで型推論さんは、<code>Derived2</code> と <code>Derived1</code> の共通の親である <code>Base</code> が <code>U</code> だと結論付ける。
したがって <code>f()</code> の戻り値型は <code>List[Base]</code> ということになる。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Scalaのimplicit]]></title>
    <link href="http://tkawachi.github.io/blog/2013/09/28/scala-implicit/"/>
    <updated>2013-09-28T22:16:00+09:00</updated>
    <id>http://tkawachi.github.io/blog/2013/09/28/scala-implicit</id>
    <content type="html"><![CDATA[<p>Scala の implicit のお勉強メモ。</p>

<h2>なぜ implicit を使いたくなるか？</h2>

<p>コード片を見ただけではわからなくなるので、暗黙的な記述はあまり使わない方がいいんじゃないかと個人的に思うのだけど。
それでも便利な使い道があるから使われているみたい。</p>

<p>今自分が知っているところで次のパターンがあるみたい。
他の便利な使い方もきっとあるんじゃなかろうか。</p>

<ul>
<li>既存のクラスを変更せずにメソッドを追加したいとき (pimp my library pattern)。 implicit な関数, implicit なクラスを使う。</li>
<li>型パラメータ情報を実行時に使いたいとき。implicit パラメータをつかう。</li>
<li>共通のインタフェースを持たないクラス群に、共通のインタフェースをあとづけするとき (CONCEPT pattern)。implicit パラメータをつかう。</li>
</ul>


<!-- more -->


<h3>pimp my library pattern</h3>

<p>既存クラスに対してメソッドをあと付けしたいときに使う。
既存クラスが自分のメンテナンスできる範囲で書き換えてOKならこのパターン使わなくていいと思う。
既存クラスがサードパーティライブラリから提供されている場合など、書き換えられない、書き換えるのが面倒ときに使う。</p>

<p>やり方は 2.9 以前の場合は</p>

<ol>
<li>既存クラスをクラスのラッパークラスを定義する</li>
<li>既存クラスからラッパークラスへの暗黙的変換関数を定義する(implicit 関数)</li>
</ol>


<p>(pimp my library pattern)で、2.10 以降の場合は <a href="http://docs.scala-lang.org/overviews/core/implicit-classes.html">implicit class</a> が導入されたのでこれを使うんだと思う。</p>

<p>ここでは <code>Int</code> 型に関数 <code>f1</code> をあと付けしたいとする。</p>

<h4>pimp my libarary pattern</h4>

<p>pimp my library pattern ではまずラッパークラスを定義して、</p>

<pre><code>class MyRichInt(x: Int) {
    def f1 = …
}
</code></pre>

<p>暗黙的変換関数を定義する。</p>

<pre><code>object MyRichInt {
    implicit def intToMyRichInt(x: Int) = new MyRichInt(x)
}
</code></pre>

<p>使う時は暗黙的変換関数を import すれば、メソッドが増えたように感じる。</p>

<pre><code>import MyRichInt._
123.f1 // new MyRichInt(123).f1 相当
</code></pre>

<h4>Implicit class</h4>

<p>Implict class 2.10 から導入された機能。
pimy my library pattern が簡単に書けるようになった感じ。
こんな感じで定義。</p>

<pre><code>object Helpers {
    implicit class IntWithF(x: Int) {
        def f1 = …
    }
}
</code></pre>

<p>使う時は import する。
既存クラスに存在しないメンバを呼び出した場合に、暗黙的に変換できるクラスにメンバがあれば、コンパイラさんが変換→呼び出しという風にしてくれる。</p>

<pre><code>import Helpers._
123.f1 // new IntWithF(123).f1 相当
</code></pre>

<p>これでプログラマ的には既存の Int 型には無かったメンバ <code>f1</code> が増えたかのように扱える。</p>

<p>関連する項目として
<a href="http://docs.scala-lang.org/ja/overviews/core/value-classes.html">value class</a>
がある。
これを一緒に使えば暗黙変換するとき <code>new</code> されなくなる（メモリ割り当てされなくなる）ので
使えるときは使うのがいい。
頻繁に使われるものの場合は速くなりそう。</p>

<h3>型パラメータ情報を実行時に使いたいとき</h3>

<p>JVMは型パラメータをコンパイル時に消しちゃうので実行時には型パラメータの情報は使えない。
<code>def f[A] = new A // 間違い</code> とかしたいときに困る。</p>

<p>そんなときは最後の引き数リストに implicit な <code>ClassTag</code> を受け取るようにすればいいみたい。</p>

<pre><code>def f[A](implicit c: ClassTag[A]) = c.runtimeClass.newInstance().asInstanceOf[A]
</code></pre>

<p><code>c</code> 経由でインスタンスを作ったり出来る。
呼び出し時は <code>c</code> を渡す必要はない。
<code>f[Int]</code> などとして呼び出せる。</p>

<h3>CONCEPT pattern</h3>

<p>既存のクラス群が共通インタフェースを持ってたらひとつの関数で同じように処理できるのに、、ってときに使うパターン。
既存のクラスが書き換えられるなら、インタフェースを新規に作って実装しちゃってもいいんじゃないかと思わなくもないけど、アルゴリズムに関連する部分は分けておきたいなんてこともあるのかもしれない。</p>

<p>この共通インタフェースのことを concept っていうらしい。</p>

<p><code>Int</code> と <code>String</code> が両方共 <code>double</code> っていう関数を持っていたら、ステキなアルゴリズム（関数）がかけるのになあ、とする。</p>

<pre><code>trait DoubleConcept[A] {
    // 共通インタフェース
    def double(v: A): A
}
implicit val doubleInt = new DoubleCondept[Int] {
    // Int の double 定義
    def double(v: Int) = v * 2
}
implicit val doubleString = new DoubleConcept[String] {
    // String の double 定義
    def double(v: String) = v + v
}

def suteki[A](v: A)(implicit c: DoubleCondept[A]) = … // c.double(v) を使ったステキアルゴリズム

suteki(123) // suteki(123)(doubleInt) 相当
suteki("ABC") // suteki(ABC)(doubleString) 相当
</code></pre>

<p>型ごとの共通インタフェース実装を implicit val として定義しておいて、 implicit なパラメータリストでそれを暗黙的に渡す。
暗黙的過ぎて難しい。</p>

<p>ともあれ <code>suteki</code> 関数のなかでは <code>Int</code> と <code>String</code> が両方共 <code>double</code> という共通操作を持っているという前提で関数がかける。
<code>suteki</code>関数呼び出し時の <code>v</code> 引き数の型により、<code>c</code> が <code>doubleInt</code> なのか <code>doubleString</code> なのかはコンパイラが選択してくれる。</p>

<h2>雑感</h2>

<p>Scala の implicit は黒魔術。
使いたくなるパターンは多くなさそうなので用途を抑えておけば理解しやすい。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[テストデータのセットアップに trait を使う]]></title>
    <link href="http://tkawachi.github.io/blog/2013/09/23/use-trait-to-setup-test-data/"/>
    <updated>2013-09-23T23:59:00+09:00</updated>
    <id>http://tkawachi.github.io/blog/2013/09/23/use-trait-to-setup-test-data</id>
    <content type="html"><![CDATA[<p>9月半ばから始まった
<a href="https://www.coursera.org/course/progfun">Functional Programming Principles in Scala</a>
を受講している。
課題内のテストの書き方でこうやるのか、というところがあったのでメモ。</p>

<p>テストケース間でデータを共有したいときがある。
たとえば以下の例では <code>data1</code> と <code>data2</code> が共通なので共通化したくなる。</p>

<pre><code>class FooSuite extends FunSuite {
    test("test A") {
        val data1 = new FooData(…)
        val data2 = new FooData(…)
        // tests with data1 and data2
    }

    test("test B") {
        val data1 = new FooData(…)
        val data2 = new FooData(…)
        // another tests with data1 and data2
    }
}
</code></pre>

<p>普通は以下のようにメンバ変数にしたくなると思う。</p>

<pre><code>class FooSuite extends FunSuite {
    val data1 = new FooData(…)
    val data2 = new FooData(…)

    test("test A") {
        // tests with data1 and data2
    }

    test("test B") {
        // another tests with data1 and data2
    }
}
</code></pre>

<p>この方法は少し問題がある。</p>

<ul>
<li><code>new FooData(…)</code> が例外を出した場合に、<code>FooSuite</code> のインスタンス化に失敗するという問題がある</li>
<li><code>FooData</code> が mutable な場合に、前に実行したテストの内容により結果が変わる可能性がある</li>
</ul>


<p>課題のテストケースでは trait を使って以下のようにしていた。</p>

<pre><code>class FooSuite extends FunSuite {
    trait TestData {
        val data1 = new FooData(…)
        val data2 = new FooData(…)
    }

    test("test A") {
        new TestData {
            // tests with data1 and data2
        }
    }

    test("test B") {
        new TestData {
            // another tests with data1 and data2
        }
    }
}
</code></pre>

<p>各テスト内で <code>TestData</code> trait を継承した無名クラスを作り、無名クラスのコンストラクタ内でテストを実行する。
こうすることで <code>new FooData(…)</code> の実行はテスト実行時になり、各テストごとにデータが初期化されるので、上にあげた問題が解消する。</p>

<p><a href="http://www.scalatest.org/user_guide/sharing_fixtures">Sharing fixtures</a> をみると他の方法もいろいろある。
一番上にある Calling get-fixture methods が一番単純ぽい。
この方法で例を書き換えるとこうなる。</p>

<pre><code>class FooSuite extends FunSuite {
    def fixture = new {
        val data1 = new FooData(…)
        val data2 = new FooData(…)
    }

    test("test A") {
        val f = fixture
        // tests with f.data1 and f.data2
    }

    test("test B") {
        val f = fixture
        import f._
        // another tests with data1 and data2
    }
}
</code></pre>

<p>無名クラスのメンバとしてテストデータを作る。
こっちのほうがインデント少なくていいかも。
<code>import f._</code> すれば <code>f.</code> prefix 要らないしね。
<code>new</code> のあとクラス名無くてもコンパイル通るんだ… 知らなかったよ。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ActiveRecord のモデルを整理する7つのパターン]]></title>
    <link href="http://tkawachi.github.io/blog/2013/09/21/active-model-7-pattern/"/>
    <updated>2013-09-21T21:18:00+09:00</updated>
    <id>http://tkawachi.github.io/blog/2013/09/21/active-model-7-pattern</id>
    <content type="html"><![CDATA[<p><a href="http://blog.codeclimate.com/blog/2012/10/17/7-ways-to-decompose-fat-activerecord-models/">7 Patterns to Refactor Fat ActiveRecord Models</a>
という記事があり、読もう読もうと思いつつ1年くらい経ってしまった。
ようやく読んだので理解した内容を書いておく。
コード例は元記事のもの。</p>

<!-- more -->


<p>Rails で thin controller, fat model を心がけていると、model がマジで激太りしてヤバくなる。
実際に自分が仕事で書いている rails アプリも激太りしててヤバい。
この blog の筆者が作っている <a href="https://codeclimate.com/">CodeClimate</a> で C 判定をもらう程度には肥満体型になっている。</p>

<h2>Mixinに抜き出さない!</h2>

<p>Model が太ってきた時に考えるのは <code>ActiveSupport::Concern</code> を使って感心事を抜き出して、Mixin にすることだと思う。
実際に手元のアプリでも <code>models/concerns/</code> なんていうディレクトリがあったりする。</p>

<p>でもこれはアンチパターン。
Mixin は継承と同じように複雑さを増す。
やってみると、さほど綺麗に分けられないんだよね。
記事では mixin はするな、と書いてある。</p>

<p>ここからがパターンの紹介。</p>

<h2>1. Value object の抽出</h2>

<p><a href="http://en.wikipedia.org/wiki/Value_object">Value object</a>
は値が等しければ等しいとされるようなオブジェクトで、だいたいは immutable。
この value object を抜き出して、関連するロジックを抜き出したクラスに移す。</p>

<p>どんなときに使うか？
属性に強く結びついたロジックがあるとき。</p>

<p>例として挙げられているのは、電話番号、お金など。
CodeClimate には AからF の値をとる <code>Rating</code> value object があるらしい。</p>

<pre><code>class Rating
  include Comparable

  def self.from_cost(cost)
    if cost &lt;= 2
      new("A")
    elsif cost &lt;= 4
      new("B")
    elsif cost &lt;= 8
      new("C")
    elsif cost &lt;= 16
      new("D")
    else
      new("F")
    end
  end

  def initialize(letter)
    @letter = letter
  end

  def better_than?(other)
    self &gt; other
  end

  def &lt;=&gt;(other)
    other.to_s &lt;=&gt; to_s
  end

  def hash
    @letter.hash
  end

  def eql?(other)
    to_s == other.to_s
  end

  def to_s
    @letter.to_s
  end
end
</code></pre>

<p><code>cost</code> から rating を計算するロジックと、比較ロジックがこのクラスに抜き出されている。
<code>#hash</code>, <code>#eql?</code> を定義しておくと、hash key として使うことができる。</p>

<p>ActiveRecord 側。
<code>rating</code> は DB に保存された値から計算される値みたい。</p>

<pre><code>class ConstantSnapshot &lt; ActiveRecord::Base
  # …

  def rating
    @rating ||= Rating.from_cost(cost)
  end
end
</code></pre>

<p>Value object として抜き出せるものがあれば、間違いなく抜き出したほうがいいね。</p>

<h2>2. Service object の抽出</h2>

<p>以下の基準の１つ以上に合致したときには service object の抜き出しを薦めている。</p>

<ul>
<li>アクションが複雑なとき</li>
<li>アクションが複数のモデルに触るとき</li>
<li>アクションが外部サービスとやりとりするとき</li>
<li>アクションがモデルの主な関心事ではないとき</li>
<li>アクションを実行するのにいくつもの方法があるとき（GoFのストラテジパターン）</li>
</ul>


<p>以下の例はユーザ認証を行う service object。</p>

<pre><code>class UserAuthenticator
  def initialize(user)
    @user = user
  end

  def authenticate(unencrypted_password)
    return false unless @user

    if BCrypt::Password.new(@user.password_digest) == unencrypted_password
      @user
    else
      false
    end
  end
end
</code></pre>

<p>ここで <code>user</code> がモデルで、認証というアクションを service object として抽出している。</p>

<p>結局のところ「複雑なメソッド（群）を見つけたら別のクラスにしましょう」ということかな。</p>

<h2>3. Form object の抽出</h2>

<p>フォームの submit で複数のモデルが更新される場合などに使うパターン。
以下の例は <code>User</code> と <code>Company</code> の両方を更新する。</p>

<pre><code>class Signup
  include Virtus

  extend ActiveModel::Naming
  include ActiveModel::Conversion
  include ActiveModel::Validations

  attr_reader :user
  attr_reader :company

  attribute :name, String
  attribute :company_name, String
  attribute :email, String

  validates :email, presence: true
  # … more validations …

  # Forms are never themselves persisted
  def persisted?
    false
  end

  def save
    if valid?
      persist!
      true
    else
      false
    end
  end

private

  def persist!
    @company = Company.create!(name: company_name)
    @user = @company.users.create!(name: name, email: email)
  end
end
</code></pre>

<p><code>Signup</code> クラスは <a href="https://github.com/solnic/virtus">Virtus</a> を使うことで、
ActiveModel のように属性を持つことができる。
<a href="http://api.rubyonrails.org/classes/ActiveModel/Naming.html"><code>ActiveModel::Naming</code></a>と
<a href="http://api.rubyonrails.org/classes/ActiveModel/Conversion.html"><code>ActiveModel::Conversion</code></a>は、つけとくと良いことがあるみたい。
<a href="http://api.rubyonrails.org/classes/ActiveModel/Validations.html"><code>ActiveModel::Validations</code></a> を include することで validation も掛けられる。</p>

<h2>4. Query object の抽出</h2>

<p>複雑なクエリを発行するときは query object を使うといいかも。
放置されたアカウントを探す query object の例。</p>

<pre><code>class AbandonedTrialQuery
  def initialize(relation = Account.scoped)
    @relation = relation
  end

  def find_each(&amp;block)
    @relation.
      where(plan: nil, invites_count: 0).
      find_each(&amp;block)
  end
end
</code></pre>

<p>コンストラクタに渡されているのは <code>ActiveRecord::Relation</code> のインスタンス。
他の条件がついた relation を渡すと、クエリを組み立てることができる。</p>

<pre><code>old_accounts = Account.where("created_at &lt; ?", 1.month.ago)
old_abandoned_trials = AbandonedTrialQuery.new(old_accounts)
</code></pre>

<p>この手のクラスは隔離した状態でのテストを頑張らず、DBにアクセスする形でテストしたほうがいい。</p>

<h2>5. View object の導入</h2>

<p>表示に限ったロジックを書いている場合には、それを抜き出すことを考える。
「もし別のインターフェース（例えば音声コントロールのUI）を実装するときに必要かな？」と考えて No なら view object が向いてる。
以下は Code Climate のドーナツチャートの例。</p>

<pre><code>class DonutChart
  def initialize(snapshot)
    @snapshot = snapshot
  end

  def cache_key
    @snapshot.id.to_s
  end

  def data
    # pull data from @snapshot and turn it into a JSON structure
  end
end
</code></pre>

<h2>6. Policy object の抽出</h2>

<p>読み込みポリシーに特化したオブジェクト。
ビジネスルールをひとつカプセル化する。</p>

<p>Service object に似ているが、service object は操作、 policy object は読み込みを担当。
Query object にも似ているが、query object は SQL 発行、 policy object はメモリ上のドメインモデル読み込みを担当する。</p>

<pre><code>class ActiveUserPolicy
  def initialize(user)
    @user = user
  end

  def active?
    @user.email_confirmed? &amp;&amp;
    @user.last_login_at &gt; 14.days.ago
  end
end
</code></pre>

<p>上記の例は、だれが &ldquo;active?&rdquo; か、という定義を与えている。</p>

<h2>7. Decorator の抽出</h2>

<p>既存の機能の上に機能を足したいときに使うパターン。
たとえばコメント書き込み時に、Facebook wall へもポストするような時に使う。</p>

<pre><code>class FacebookCommentNotifier
  def initialize(comment)
    @comment = comment
  end

  def save
    @comment.save &amp;&amp; post_to_wall
  end

private

  def post_to_wall
    Facebook.post(title: @comment.title, user: @comment.author)
  end
end
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[sbt build definition]]></title>
    <link href="http://tkawachi.github.io/blog/2013/09/16/sbt-build-definition/"/>
    <updated>2013-09-16T22:17:00+09:00</updated>
    <id>http://tkawachi.github.io/blog/2013/09/16/sbt-build-definition</id>
    <content type="html"><![CDATA[<p><a href="http://scalajp.github.io/sbt-getting-started-guide-ja/">始める sbt</a>
を以前読んだときは
<a href="http://scalajp.github.io/sbt-getting-started-guide-ja/basic-def/">.sbt ビルド定義</a>
のところでぐっと難しくなってよくわからなくなった。
今日復習したのでメモ。</p>

<p>最初にまとめ。</p>

<ul>
<li><code>key := value</code> は新しい設定項目を追加する関数のようなもの(<code>Setting[T]</code>)を定義する。</li>
<li><code>Setting[T]</code> の入力は変更されない。</li>
<li><code>.sbt</code> を読み込むと <code>Setting[T]</code> のリストができる。<code>Setting[T]</code> のリストは、依存関係を考慮してソートされた後に適用される。</li>
<li><code>.sbt</code> の空行で区切られた塊は Scala の式。文ではないので <code>val</code>, <code>object</code>, <code>class</code> などは書けない。</li>
<li><code>key := value</code> は <code>key.:=(value)</code> といったメソッド呼び出しを別の書き方にしたもの。</li>
<li>sbtデフォルトの設定項目は
<a href="https://github.com/sbt/sbt/blob/0.13/main/src/main/scala/sbt/Keys.scala"><code>sbt.Keys</code></a>
に定義されている。</li>
<li><code>TaskKey[T]</code> は毎回計算されるキー。</li>
<li>sbtコンソールでアクセスするときは <code>SettingKey[T]</code>, <code>TaskKey[T]</code> などを呼び出す際の第一引き数文字列を使う。</li>
<li>キーの詳細はsbtコンソールから <code>inspect</code> で確認できる。</li>
</ul>


<!-- more -->


<p><code>Setting[T]</code> は、設定を入力に与えると、新しいキーと値のペアを追加したり、既存のキーを新しい値で追加したりといった変換を表す。
変換っていうのは、なにかを入力されたら、それを変更した結果を返すということで、関数みたいな概念で捉えればいいのだろう。
<code>Setting[T]</code>は関数型の精神に則り、入力値は変更しない。</p>

<p><code>.sbt</code> ファイル中の <code>key := value</code> は変換(<code>Setting[T]</code>)を定義している。
たとえば <code>name := "hello"</code> とあれば、キーが<code>name</code>で値が<code>"hello"</code>のペアを追加・上書きする変換を定義する。
<code>T</code> は設定値の型なので、この場合は <code>Setting[String]</code> が定義されたことになる。</p>

<p><code>.sbt</code> ファイルには変換が沢山含まれているので、結果として変換(<code>Setting[T]</code>)のリストができる。</p>

<p><code>Setting[T]</code> のリストに、sbt のデフォルトの設定を入力すると、<code>.sbt</code>ファイルが反映された設定が得られる。
<code>Setting[T]</code>が入力値を変更しないのでsbtのデフォルトの設定は変更されない。</p>

<p><code>.sbt</code> ファイルで <code>name := "hello"</code> と書いたら、<code>name.:=("hello")</code> のこと。
<code>key</code> の型は <code>SettingKey[String]</code> で、 <code>:=</code> は <code>String</code> を引数にとり <code>Setting[String]</code> を返す。
間違った型の値を代入しようとした場合には(例：<code>name := 1</code>)、型チェックでエラーになる。</p>

<p><code>:=</code> メソッドの他にも <code>+=</code> （リストへの要素追加）などがある。</p>

<p>sbtに用意されている設定項目（キー）は
<a href="https://github.com/sbt/sbt/blob/0.13/main/src/main/scala/sbt/Keys.scala"><code>sbt.Keys</code></a>
object に <code>SettingKey[T]</code> 型で定義されている。
<code>.sbt</code>ファイルの内容が評価される時は <code>import sbt.Keys._</code> された状態なので、 <code>sbt.Keys._</code> はパッケージ修飾なしに参照できる。
<a href="https://github.com/sbt/sbt/blob/0.13/main/src/main/scala/sbt/Keys.scala"><code>sbt.Keys</code></a>
は重要。
設定項目を探すときにちょくちょく参照することになる気がする。</p>

<p>たとえば <code>name</code> はこんな感じ。</p>

<pre><code>val name = SettingKey[String]("name", "Project name.", APlusSetting)
</code></pre>

<p>前述のように<code>SettingKey[String]</code>であることがわかる。</p>

<p><a href="https://github.com/sbt/sbt/blob/0.13/main/src/main/scala/sbt/Keys.scala"><code>sbt.Keys</code></a>
には <code>SettingKey[T]</code> 型以外にも、 <code>TaskKey[T]</code>, <code>InputKey[T]</code>, <code>AttributeKey[T]</code> 型の値が定義されてる。
<code>compile</code> のように sbt コンソールから入力するたびに実行してくれないと困るものは
<code>TaskKey[T]</code> として定義されている。
たとえば <code>compile</code> はこんな感じ。</p>

<pre><code>val compile = TaskKey[Analysis]("compile", "Compiles sources.", APlusTask)
</code></pre>

<p><code>SettingKey[T]</code>は一度計算されると結果が保持される。
<code>TaskKey[T]</code>は毎回計算される。
<code>SettingKey[T]</code>は<code>TaskKey[T]</code>に依存できない。</p>

<p><code>InputKey[T]</code>, <code>AttributeKey[T]</code> はまだ知らない。</p>

<p>sbtコンソールから入力するのはキーコンストラクタの第一引き数の文字列。</p>

<pre><code>val scalacOptions = TaskKey[Seq[String]]("scalac-options", "Options for the Scala compiler.")
</code></pre>

<p>とあったら <code>scalac-options</code> がsbtコンソールから入力時に指定する文字列になる。
<code>sbt.Keys</code> に CamelCase で定義されたものは大体コンソール入力時には小文字、ハイフン区切りになっている。</p>

<p>キーに関する情報はsbtコンソールから <code>inspect キー名</code> で得られる。</p>

<p><code>.sbt</code> ファイルの先頭に <code>import</code> 文を複数行書ける。<code>import</code> 文の間は空行をあけなくていい。
他の <code>SettingKey[T]</code> を参照するときに使うのかな。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[akka memo]]></title>
    <link href="http://tkawachi.github.io/blog/2013/09/15/akka-memo/"/>
    <updated>2013-09-15T21:30:00+09:00</updated>
    <id>http://tkawachi.github.io/blog/2013/09/15/akka-memo</id>
    <content type="html"><![CDATA[<p>Scala 2.10 から付いてくる Akka の Actor についてのお勉強メモ。
全然まとまっていないが晒しておく。</p>

<!-- more -->


<h2>概念</h2>

<h3>Actor</h3>

<p><code>akka.actor.Actor</code>。
メッセージを受けて処理をする人。</p>

<h3>Mailbox</h3>

<p>Actorへのメッセージが溜まるところ。</p>

<h3>Supervision</h3>

<p>Actor間の依存関係のこと。
Actorインスタンスはツリー構造になっている。
親が supervisor となる。</p>

<p>Actor が失敗したらどうするかは supervisor の actor が制御する。</p>

<p>親 actor が shutdown したら、その子どもは全て shutdown する。</p>

<p>タスクのまとまり毎にサブツリーを形成するようにすると良いらしい。</p>

<h3>Actor Path</h3>

<p>Actorインスタンスにはツリー構造上の位置を表す文字列がついており、これを actor path と呼ぶ。
<code>/</code>, <code>/user</code>, <code>/user/abc</code> など。</p>

<h3>ActorSystem</h3>

<p><code>akka.actor.ActorSystem</code>。
ツリー全体を管理するもの。
ActorSystemはスレッドを何本も使う重い構造なので沢山作りすぎない。</p>

<h3>Router</h3>

<p>Actor の一種。メッセージを受け取って他の actor に投げる(Routingする)。
投げられる側を routee と呼ぶ。
Routee は router の子どもになる。</p>

<p>以下の様な router が提供されている。どのようにルーティングするかは名前から大体想像がつく。
ロードバランサ的なやつですかね。</p>

<ul>
<li>akka.routing.RoundRobinRouter</li>
<li>akka.routing.RandomRouter</li>
<li>akka.routing.SmallestMailboxRouter</li>
<li>akka.routing.BroadcastRouter</li>
<li>akka.routing.ScatterGatherFirstCompletedRouter</li>
<li>akka.routing.ConsistentHashingRouter</li>
</ul>


<h3>Props</h3>

<p><code>akka.actor.Props</code>。
Actorをインスタンス化する際の設定。
Immutable なので複数の actor をインスタンス化する際に使いまわせる。</p>

<h2>ライフサイクル</h2>

<p>生まれてから死ぬまで。</p>

<p>停止信号を受け取ると以下の手順で止まる。</p>

<ol>
<li>mailbox メッセージの処理をやめる</li>
<li>子どもに停止信号を送る</li>
<li>全ての子どもから停止完了がくるのを待つ</li>
<li>自分自身の停止完了プロセスを実行

<ol>
<li><code>postStop()</code> を呼び出す</li>
<li>mailbox をダンプ</li>
<li><code>DeathWatch</code> に停止完了を知らせる</li>
<li>親に停止完了を知らせる</li>
</ol>
</li>
</ol>


<h3>止めかたのパターン</h3>

<ul>
<li>ActorSystem を shutdown() する。</li>
<li>PoisonPill を actor に送る。通常メッセージと同じように mailbox に送られ、処理されるときに actor が停止する。</li>
<li><code>context.stop(self)</code>, <code>context.stop(child)</code> で止める。</li>
</ul>


<h3>殺しかた</h3>

<ul>
<li>Kill を送ると即座に死ぬ</li>
</ul>


<h3>問題が起きたときの判断</h3>

<p>以下のいずれか。</p>

<ul>
<li>Resume</li>
<li>Restart</li>
<li>Terminate</li>
<li>Escalate</li>
</ul>


<h3>Restart</h3>

<ul>
<li>子どもをterminate。自分をterminate。</li>
<li>子どもの mailbox は保持される。 mailbox を破棄したい時は supervisor が terminate, recreate すること。</li>
</ul>


<h3>ストラテジー</h3>

<ul>
<li>one-for-one strategy &mdash; default

<ul>
<li>Restart (defaultDecider)</li>
</ul>
</li>
<li>all-for-one strategy</li>
</ul>


<p><a href="http://doc.akka.io/docs/akka/snapshot/general/supervision.html#supervision-restart">What Restarting Means</a></p>

<p>失敗は３つのカテゴリに分けられる。</p>

<ul>
<li>特定のメッセージを処理する際のプログラムエラー</li>
<li>メッセージを処理する際に使われる外部リソースの一時的なエラー</li>
<li>Actorの内部状態が壊れた</li>
</ul>


<p>内部状態が壊れたら内部状態を破棄しなければならない。Supervisorや他の子どもが壊れた内部状態の影響を受けなければ、restartするのがベスト。
Restartの際には内部的に新しい Actor がインスタンス化され、ActorRefの参照しているものが切り替わる。
ActorRef の存在意義のひとつは、この切り替え。</p>

<p>Actorが内部で作った子 Actor の ActorRef を外部に保持していると、
Actor restart 時に無効な参照になる。</p>

<p>ガーディアン直下の actor に対応する ActorRef は ActorSystem 終了時まで有効だろうと思う。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ScalaTestでMockito]]></title>
    <link href="http://tkawachi.github.io/blog/2013/08/26/mockito-scala/"/>
    <updated>2013-08-26T10:14:00+09:00</updated>
    <id>http://tkawachi.github.io/blog/2013/08/26/mockito-scala</id>
    <content type="html"><![CDATA[<p>ScalaTestでMockitoを使うためのお勉強ノート</p>

<h2>Setup</h2>

<p><code>build.sbt</code> に追加。</p>

<pre><code>libraryDependencies ++= Seq(
  "org.scalatest" %% "scalatest" % "1.9.1" % "test",
  "org.mockito" % "mockito-core" % "1.9.5" % "test"
)
</code></pre>

<p>テストで <code>MockitoSugar</code> を mixin し、以下の import 行を追加。</p>

<pre><code>import org.mockito.Matchers._
import org.mockito.Mockito._
</code></pre>

<h2>Mock作成</h2>

<pre><code>// ClassToMock のモックを作成
val m = mock[ClassToMock]
</code></pre>

<p>作ったモックはデフォルトで全メソッドコールに対して <code>null</code> を返す。
メソッドの戻り値として<code>null</code>ではなくモックを返したい時は次のようにする。</p>

<pre><code>// メソッド呼び出しでモックを返すモック
mock[ClassToMock](RETURNS_MOCKS)
// 返されたモックもモックを返すモック
mock[ClassToMock](RETURNS_DEEP_STUBS)
</code></pre>

<h2>引数に応じて戻り値を変える</h2>

<p><code>when(メソッド呼び出し).thenReturn(戻り値)</code> で登録する。
メソッド呼び出し部の引き数には <code>any</code> で任意の型の任意の値に、<code>anyString</code>, <code>anyBoolean</code>, <code>anyByte</code>, <code>anyChar</code>などで基本的な型の任意の値に <code>anyVararg</code> で任意の可変引き数にマッチさせることができる。</p>

<pre><code>// m.method1(何か) が呼ばれたら 10 を返す
when(m.method1(any)).thenReturn(10)
</code></pre>

<p>引数が２つ以上あり、いずれかで <code>any</code> などのマッチャーを使った場合には、他の引き数もマッチャーにする必要がある。
オブジェクトが等しいことを示すマッチャーは <code>eq(obj)</code> で作れる。</p>

<p>後から登録したものが先にマッチするので、条件のゆるいもの（マッチ範囲が広いもの）を先に書く。</p>

<h3>１回目、２回目で違う値を返す</h3>

<p><code>thenReturn()</code> の可変引き数版を使う</p>

<pre><code>// 最初は 10, 次は 20, それ以降はずっと 30 を返す
when(m.method1()).thenReturn(10, 20, 30)
</code></pre>

<h2>例外を起こす</h2>

<pre><code>// method1() が呼ばれたら例外を起こす
when(m.method1()).thenThrow(new RuntimeException("Gau gau"))
</code></pre>

<p><code>thenReturn</code> と同じように１回目、２回目で違う例外を起こすことも可能。
むしろ <code>thenReturn</code> と組み合わせることができる。</p>

<pre><code>when(m.method1())
  .thenReturn(10, 20) // １回目は10, ２回目は20を返す
  .thenThrow(new FooException, new BarException) // ３、４回目は例外
  .thenReturn(30) // ５回目以降は30を返す
</code></pre>

<h2>オブジェクトの一部をモックする(spy)</h2>

<p><code>mock[ClassToMock]</code> はフルのモック。一部だけモックしたい場合はこっち。<code>spy</code>と呼ぶ。</p>

<pre><code>// obj は普通のオブジェクト
val s = spy(obj)
// s.method1(何か) が呼ばれたら obj の実装を使わずに 10 を返す。
doReturn(10).when(s).method1(any[ClassOfArg])
</code></pre>

<p><code>thenReturn</code> が <code>doReturn</code> になって順番が代わり、メソッド呼び出しも <code>when</code> の外に出す。
<code>thenReturn</code>の書き方では実際のメソッドが呼ばれるので、呼ばれては困るときにこちらの書き方をする。</p>

<p>この記法の場合は <code>any</code> を使うときに型を指定しなければならなかった
（理由はわかってない）。</p>

<h2>メソッドが呼び出されたことを確認する(verify)</h2>

<p><code>when()</code>, <code>thenReturn()</code>, <code>doReturn()</code> などは関数呼び出しの前に用意する。
用意したものがテスト中で呼び出されなくても問題ない。</p>

<p>呼び出されたことを確認するには <code>verify()</code> を使う。</p>

<pre><code>// テストを実行
m.method1(123);
// method1() が何らかの整数引き数で呼び出されたことを確認
verify(m).method1(anyInt);
</code></pre>

<p>複数回呼び出されたことを確認するときは、<code>verify()</code>の第二引き数で回数指定をする。</p>

<pre><code>// 2回呼び出されたことを確認
verify(m, times(2)).method1(anyInt)
// 少なくとも2回
verify(m, atLeast(2)).method1(anyInt)
// 多くとも3回
verify(m, atMost(3)).method1(anyInt)
</code></pre>

<h3>呼び出されてないことを確認する</h3>

<p><code>never</code> を使う。</p>

<pre><code>// 一度も呼ばれてないことを確認
verify(m, never).method1(anyInt)
</code></pre>

<h2>より進んだ使い方</h2>

<p><a href="http://docs.mockito.googlecode.com/hg/latest/org/mockito/Mockito.html">Mockitoのドキュメント</a>
に書いてある。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[「すごい Haskell たのしく学ぼう！」読書 (1)]]></title>
    <link href="http://tkawachi.github.io/blog/2013/06/16/1/"/>
    <updated>2013-06-16T20:49:00+09:00</updated>
    <id>http://tkawachi.github.io/blog/2013/06/16/1</id>
    <content type="html"><![CDATA[<p>「Scala実践プログラミング」を読書したり、Scala 関連の blog を読んでいたりすると、
「HaskellではこうやるのをScalaで実現するには云々」という話が多くて困る。
なぜなら僕はHaskell知らないから。</p>

<p>と開き直ってもしかたがないので Haskell の入門書として評価が高そうな「すごい Haskell たのしく学ぼう！」
を購入した。
Kindle版があるのは素晴らしい。</p>

<p>読書メモを残しておく。今日はイントロを読んだ。</p>

<ul>
<li>Haskell はおもしろい</li>
<li>困ったら freenode #haskell へ (日本語だとどこなんだろう？)</li>
<li>純粋関数型言語で宣言的 (&lt;&ndash;> 命令形言語で手続き的)</li>
<li>副作用なし。参照透明性(同じ引数で関数が呼ばれたら同じ値を返す)。</li>
<li>遅延評価</li>
<li>静的型付けで型推論あり。</li>
<li>言語仕様は TheHaskellReport。最新は2010年。</li>
<li>GHC: コンパイラと対話プログラム(ghci)</li>
<li>ghci のコマンド

<ul>
<li>:q &mdash; 終了</li>
<li>:l foo &mdash; foo.hs のロード</li>
<li>:r &mdash; 最後の :l を再実行</li>
</ul>
</li>
<li>ワークフロー

<ol>
<li>foo.hs を作る</li>
<li>:l foo</li>
<li>foo.hs を編集</li>
<li>:r (以下繰り返し)</li>
</ol>
</li>
</ul>


<p>語り口が柔らかで読みやすい。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Octopress で universal analytics へ切り替え]]></title>
    <link href="http://tkawachi.github.io/blog/2013/06/15/1/"/>
    <updated>2013-06-15T21:35:00+09:00</updated>
    <id>http://tkawachi.github.io/blog/2013/06/15/1</id>
    <content type="html"><![CDATA[<p>この blog では google analytics を入れているが、それを今年の春に公開された
<a href="https://support.google.com/analytics/answer/2790010?hl=ja">universal analytics</a>
に切り替えてみた。
なんか色々できることが増えてるみたい。</p>

<p>まず、既存のプロパティをそのまま universal analytics へ移行することは出来ない。
Google Analytics のプロパティを新しく作る必要があった。</p>

<!-- more -->


<p>次にするのは JavaScript スニペットの更新。
今までは <code>ga.js</code> を読み込んでいたが、これが <code>analytics.js</code> に変わる。
イベント送信時の syntax も変わる。</p>

<p>この blog で使っている octopress では、<code>analytics.js</code> に対応していない。
<a href="https://github.com/tkawachi/tkawachi.github.com/commit/2ecc6d3f6548de37e6ba02d0d8ac1134dc3778c0">こんな感じ</a>
でちょいちょいと変更したところ無事に動いているようだ。</p>

<p>セッションのタイムアウト時間が設定できるようになっていたり、できることが増えているようだが、まだ良くわかっていない。
ともあれ切り替えは無事にできた。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[s3:ListBucketVersions]]></title>
    <link href="http://tkawachi.github.io/blog/2013/06/13/1/"/>
    <updated>2013-06-13T16:44:00+09:00</updated>
    <id>http://tkawachi.github.io/blog/2013/06/13/1</id>
    <content type="html"><![CDATA[<p>IAM でアクセス権限を管理するのは面倒だ。
まず権限の種類が覚えきれない。</p>

<p>s3:ListBucket を許可していたのに、
Ruby の AWS SDK で
<a href="http://docs.aws.amazon.com/AWSRubySDK/latest/AWS/S3/Bucket.html#empty%3F-instance_method"><code>AWS::S3::Bucket#empty?</code></a>
にて例外が発生した。</p>

<!-- more -->


<p>調べてみたら、バージョン付けされたオブジェクトも含めて list して、空かどうか確認しているようだ。
この場合は s3:ListBucket ではなく s3:ListBucketVersions を許可しなければならないようだ。
たぶん IAM で権限管理を細かく管理している人はほとんどいないんじゃないかな。
めんどうだもの。</p>

<p>参考</p>

<ul>
<li><a href="http://docs.aws.amazon.com/AmazonS3/latest/dev/UsingIAMPolicies.html">Using IAM Policies</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[型境界]]></title>
    <link href="http://tkawachi.github.io/blog/2013/06/12/1/"/>
    <updated>2013-06-12T21:36:00+09:00</updated>
    <id>http://tkawachi.github.io/blog/2013/06/12/1</id>
    <content type="html"><![CDATA[<p>Type parameter の境界指定方法。</p>

<ul>
<li>upper bound (<code>A &lt;: U</code>): A は U またはその子クラス</li>
<li>lower bound (<code>A &gt;: L</code>): A は L またはその親クラス</li>
</ul>


<p>両方指定する(<code>A &gt;: L &lt;: U</code>)ことも可能。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[loan pattern]]></title>
    <link href="http://tkawachi.github.io/blog/2013/06/11/1/"/>
    <updated>2013-06-11T22:07:00+09:00</updated>
    <id>http://tkawachi.github.io/blog/2013/06/11/1</id>
    <content type="html"><![CDATA[<p>最近仕事で scala を書いてまして、
Java 延長線上として使う分には全く問題ないのだが、
scala ぽいこととなるとかなり怪しい。
なので初歩から少しずつ勉強して、その様子を晒しておくことにする。</p>

<p>今日は loan pattern。
リソース解放を忘れずに行うためのパターン。
C++ では RAII, golang では defer を使う場面で使うやつ。</p>

<!-- more -->


<p>以下、基本形。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'>  <span class="k">def</span> <span class="n">using</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">R</span> <span class="k">&lt;:</span> <span class="o">{</span><span class="kt">def</span> <span class="kt">close</span><span class="o">()}](</span><span class="n">r</span><span class="k">:</span> <span class="kt">R</span><span class="o">)(</span><span class="n">f</span><span class="k">:</span> <span class="kt">R</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
</span><span class='line'>    <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">f</span><span class="o">(</span><span class="n">r</span><span class="o">)</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">r</span><span class="o">.</span><span class="n">close</span><span class="o">()</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 使いかた</span>
</span><span class='line'>  <span class="n">using</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileWriter</span><span class="o">(</span><span class="s">&quot;xyz&quot;</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>    <span class="o">(</span><span class="n">f</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="c1">// f に対する操作</span>
</span><span class='line'>  <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>ポイント</p>

<ul>
<li>parameterized type の R には structural type で upper bound を指定する(<code>R &lt;: {def close()}</code>)。
これにより R には <code>close()</code> メソッドを持つ任意の型を受け付けられる。
Structural typing は scala で duck typing できる機能。便利。
R の upper bound に trait や class を指定すると継承関係がある型しか使えないので
汎用性が下がり残念な気持ちになる。注意。</li>
</ul>


<p>それにしても名前が覚えづらい。</p>

<p>参考</p>

<ul>
<li><a href="http://www.ne.jp/asahi/hishidama/home/tech/scala/sample/using.html">Scala using（ローンパターン）</a></li>
</ul>


<hr />

<p>2013/6/12: parameterized type R の指定には upper bound で structural type を指定するのではなく、 view bound (<code>R &lt;% {def close()}</code>) で structural type を指定する方が汎用性が高い。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RailsでTypeScript、再び]]></title>
    <link href="http://tkawachi.github.io/blog/2013/04/25/typescript-and-rails-again/"/>
    <updated>2013-04-25T23:22:00+09:00</updated>
    <id>http://tkawachi.github.io/blog/2013/04/25/typescript-and-rails-again</id>
    <content type="html"><![CDATA[<p>Google で typescript rails と検索すると去年12月に書いた「<a href="http://tkawachi.github.io/blog/2012/12/09/trying-typescript-rails-out/">Rails で TypeScript を動かそうとして失敗した記録</a>」というエントリが2番目に出てくる日々が続いている。
「TypeScriptをRailsで使いたい」と思った人たちは、検索結果を見て、ああ動かないのかと思うのだろう。</p>

<p>あれから状況は少しだけ改善した。
typescript-rails gem で <code>/// &lt;reference&gt;</code> が一部使えるようになった。
というか使えるようにする <a href="https://github.com/klaustopher/typescript-rails/pull/6">patch</a> を出した。</p>

<p>この patch により、<code>node</code> コマンドをインストールしてあることが前提になったので注意されたし。</p>

<p>サンプルを作ろうと思い
<a href="https://github.com/tkawachi/typescript-rails-sample/blob/051838b7/app/assets/javascripts/test.js.ts.erb">test.js.ts.erb</a>
を書いてみた。
<code>.js.ts</code> ファイルや <code>.d.ts</code> ファイルを参照できるようになっていることがわかると思う。
サンプル内でやっているように <code>jquery.d.ts</code> を参照して、 jQuery も使えるようになった。</p>

<p>一方で以下の問題が残っている。
TypeScript compiler に渡る際に違うディレクトリにコピーされるため、参照先を絶対パスで指定している。そのため <code>.erb</code> suffix を付ける必要がある。
また参照先の拡張子が <code>.js.ts</code>, <code>.d.ts</code> ならば大丈夫だが <code>.js.ts.erb</code> の場合、compiler が参照してくれない。</p>

<p>これらの問題を解消しないとちょっと本格利用はできないかなあ。
また時間がとれたらなんとかしたい。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使わないと損なバックエンドサービス]]></title>
    <link href="http://tkawachi.github.io/blog/2013/02/17/backend-services/"/>
    <updated>2013-02-17T18:47:00+09:00</updated>
    <id>http://tkawachi.github.io/blog/2013/02/17/backend-services</id>
    <content type="html"><![CDATA[<p><a href="http://slash7.com/company/">slash7</a> の Thomas Fuchs さんが自分たちのサービス
<a href="http://mir.aculo.us/2013/02/16/running-a-saas-here-are-some-services-youll-find-useful/">Freckle で使っている有償サービス群を紹介</a>している。
小さいチームでは自分のビジネスのコアに集中し、それ以外の部分に力を分散させるべからずというのはまさにその通り。</p>

<p>紹介されていたサービスは以下のとおり。
知らないサービスもいくつかあるなあ。</p>

<!-- more -->


<ul>
<li><a href="http://beta.travis-ci.com/">Travis Pro</a>
(<a href="http://about.travis-ci.org/docs/user/travis-pro/">ドキュメント</a>)
CI(継続的インテグレーション)サービス。
Open source 製品は Pro じゃない方が使える。</li>
<li><a href="http://newrelic.com/">NewRelic</a> 性能監視サービス。これは僕も使ってる。</li>
<li><a href="https://postmarkapp.com/">Postmark</a> メール配送サービス。メールを送るならマスト、らしい。メール受信もできるらしい。
同種のサービスは<a href="http://socialcompare.com/en/comparison/transactional-emailing-providers-mailjet-sendgrid-critsend">沢山ある</a>。
例えば<a href="http://sendgrid.com/">SendGrid</a>。</li>
<li><a href="https://www.honeybadger.io/">Honeybadger</a> Rails用のエラー管理ツール。
僕は <a href="http://www.exceptional.io/">Exceptional.io</a> を使っている。</li>
<li><a href="http://docraptor.com/">DocRaptor</a> HTML から PDF を生成するツール。請求書ダウンロードで使っているらしい。</li>
<li><a href="https://logentries.com/">Logentries</a> Log管理サービス。
複数サーバのログが同じ時系列で見える。検索可能。
同種のサービスに <a href="http://loggly.com/">Loggly</a> がある。</li>
<li><a href="http://www.dome9.com/">Dome9</a> ファイアウォール設定サービス。
iptablesでごにょごにょしなくてもいいらしい。</li>
<li><a href="http://webmon.com/">Webmon</a> と <a href="https://www.pingdom.com/">pingdom</a>。
サービスの可用性を測るサービス。
pingdom のほうは<a href="http://status.letsfreckle.com/">こういうステータス表示</a>もできるようだ。</li>
<li><a href="https://deadmanssnitch.com/">Dead Man’s Snitch</a> Cron が走ってなかったらメールしてくれるサービス。</li>
<li><a href="http://www.pagerduty.com/">PagerDuty</a> アラートを集めてメールなどで通知するサービス。
同種のサービスに<a href="http://www.opsgenie.com/">OpsGenie</a>。</li>
<li><a href="https://www.tinfoilsecurity.com/">Tinfoil</a> と <a href="https://www.trustwave.com/">Trustwave</a>。
セキュリティをチェックし、脆弱性がある場合に教えてくれるサービス。</li>
<li><a href="http://www.kissmetrics.com/">KISSmetrics</a>。メトリックスおよびイベントトラッキングサービス。</li>
<li><a href="http://customer.io/">Customer.io</a> お知らせメール送信サービス。最近きてない人だけに送るなんてことができる。</li>
</ul>


<p>すでに適正価格でやってくれるサービスがある場合、それを使わないで自分で作るのは馬鹿げています。使えるものは使いましょう。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[情熱の持ち方・燃やし方？]]></title>
    <link href="http://tkawachi.github.io/blog/2013/02/11/passion-study/"/>
    <updated>2013-02-11T22:28:00+09:00</updated>
    <id>http://tkawachi.github.io/blog/2013/02/11/passion-study</id>
    <content type="html"><![CDATA[<p>情熱が燃えていない。
結婚して子どもができ幸せであるが、今ひとつのめり込めるものがない。
好きなものはある。プログラミングが好きだ。
しかし覚えたての学生時代ほど燃えてはいない。
その他に趣味といえる趣味はない。</p>

<!-- more -->


<p>大学では様々なことを教えてくれる。
教授の中には情熱的な人が多かったが、情熱の持ち方・情熱の燃やし方については教えてもらった記憶が無い。
情熱の持ち方、燃やし方について教えてくれる人や場があってもいいんじゃないか？
いや、きっと自分が知らないだけで、あるに違いない。</p>

<p>世の中に同じような人は多いのではないだろうか？
情熱を燃やせば人生もっと楽しくなる人が、日本中にいるのではなかろうか。</p>

<p>現時点で解決したい事項を書いておく。</p>

<ul>
<li>情熱をもつにあたり必要な内部条件・外部条件はなにか？</li>
<li>体系的な情熱の燃やし方はあるか？</li>
<li>情熱が燃えている時と燃えていない時の判断することはできるか？</li>
</ul>


<p>まずは書籍を当たろうと Amazon で検索したところ、
<a href="http://www.amazon.co.jp/gp/product/4479793577/">情熱のスイッチ</a>
の内容が近そうである。とりあえずポチった。
なにかヒントが得られるだろうか。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[jQueryのDeferredとPromise]]></title>
    <link href="http://tkawachi.github.io/blog/2013/01/06/jquery-deferred/"/>
    <updated>2013-01-06T00:44:00+09:00</updated>
    <id>http://tkawachi.github.io/blog/2013/01/06/jquery-deferred</id>
    <content type="html"><![CDATA[<p>JavaScript(というか CoffeeScript)って90年代にブラウザ上で使われていた頃のイメージが拭えず、どうも気持ち悪くて逃げて回ってたんですが、事情があって最近は渋々書いてます。
JavaScripterの皆様にとっては何を今更だとは思いますが <a href="http://qiita.com/items/3d1cf51d7ae91305eaaa">jQuery.Deferredを使って楽しい非同期生活を送る方法</a> を読んで Deferred 便利だな、と思ったので理解したところをメモしておきます。</p>

<!-- more -->


<h2>利用シーン</h2>

<ul>
<li><code>$.get()</code> ってエラーハンドリングできないのか。使えないなー。と思ったとき</li>
<li>複数の AJAX リクエスト(などの非同期処理)を同時に開始して、全部終わったら何かしたいとき。</li>
</ul>


<h2>Deferred object</h2>

<p>キーになるのは
<a href="http://api.jquery.com/category/deferred-object/">Deferred object</a>
です。</p>

<h3>状態</h3>

<p>Deferred object は状態を持ちます。状態は３つのうちいずれか。</p>

<ol>
<li>未解決(unresolved)</li>
<li>解決済み(resolved)</li>
<li>拒否済み(rejected)</li>
</ol>


<p>実装によってはいろいろ呼び名があるみたいですが、jQuery では上のように呼ばれています。
jQuery以外の、例えば CommonJS の
<a href="http://wiki.commonjs.org/wiki/Promises/A">Promises/A</a>
では unfulfilled, fulfilled, failed がそれぞれの状態に対応します。</p>

<p>状態の遷移は「未解決→解決済み」「未解決→拒否済み」の二種類だけです。
一度、解決済みや拒否済みになったら未解決に戻ったりしませんし、解決済みから拒否済みへ遷移したりもしません。</p>

<h2>利用者</h2>

<p>このオブジェクトの利用者は</p>

<ul>
<li>a: 非同期処理をする人</li>
<li>b: 非同期処理の結果を受ける人</li>
</ul>


<p>の２人です。
aさんが状態遷移を担当し、bさんがそれに応じて処理を行う役割です。</p>

<p>Deferred object はaさんからbさんへ提供されますが、大抵の場合は Deferred の機能制限版である
<a href="http://api.jquery.com/Types/#Promise">Promise object</a>
が bさんに渡されます。
状態遷移を起こすのはaさん担当で、bさんがそれをしてはまずいので、Promiseでは状態遷移関連のメソッドが取り除かれています。
Promise は Deferred の <code>.promise()</code> メソッドで得られます。</p>

<p>非同期処理の関数コール時の戻り値として a から b に Promise object が渡されます。
処理が終わったら結果を渡すから約束手形(Promise)をもっておいてくれ、というわけですね。</p>

<h2>解決または拒否へ</h2>

<p>aさんは非同期処理が終わったら約束通り結果を渡します。
引数に処理結果を渡して<code>.resolve()</code> メソッドを呼び出すことで、解決済み状態へ遷移します。</p>

<p>処理が失敗に終わった場合には <code>.reject()</code> を呼びます。</p>

<h2>約束手形(Promise)の使い方</h2>

<p>書いてて思ったのですが、約束手形は一定の期日に支払いをする約束であるのに対して、Promise はいつ処理が完了するかわからないので少し違いました。
どちらかというとカイジの
<a href="http://fukumoto.lsx3.net/?%CC%DB%BC%A8%CF%BF%2F%CD%F8%BA%AC%C0%EE%B9%AC%CD%BA#b1869786">その気になれば10年後20年後ということも可能だろう</a>
という大金の引換券に似ています。</p>

<p>ともあれ、Promise はその時点では結果が出ていないので、すぐに結果を利用することができません。
代わりに callback を登録しておくことができます。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="c1">// 解決済みになったら呼ばれる callback を登録</span>
</span><span class='line'><span class="nx">promise</span><span class="p">.</span><span class="nx">done</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span> <span class="nx">data</span><span class="err">は処理結果</span> <span class="p">});</span>
</span><span class='line'><span class="c1">// 拒否済みになったら呼ばれる callback を登録</span>
</span><span class='line'><span class="nx">promise</span><span class="p">.</span><span class="nx">fail</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="err">エラー処理</span> <span class="p">});</span>
</span><span class='line'><span class="c1">// 解決済みもしくは拒否済みになったら呼ばれる callback を登録</span>
</span><span class='line'><span class="nx">promise</span><span class="p">.</span><span class="nx">always</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="err">処理</span> <span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>callback 複数登録する事ができ、登録した順に呼ばれます。例えば <code>done()</code> を複数回呼び出して解決済みになったときの callback を複数個登録することができます。</p>

<p><code>done()</code>, <code>fail()</code>, <code>always()</code> は Deferred の場合は Deferred, Promise の場合は Promise を返すので、method chain でつなげることができます。</p>

<h2>約束の組み合せ</h2>

<p>受け取った Promise/Deferred は <code>$.when()</code> で組み合わせることができます。
組み合わせると、渡したものすべてが解決済みになったときに解決済みになる Promise が返されます。
組み合せにより、複数の非同期処理がすべて完了したら何かを実行することができます。</p>

<p>組み合わせた場合、 callback の引数に渡される結果も増えます。
以下のコードで d1, d2 にはそれぞれ promise1, promise2 の結果が渡されます。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">$</span><span class="p">.</span><span class="nx">when</span><span class="p">(</span><span class="nx">promise1</span><span class="p">,</span> <span class="nx">promise2</span><span class="p">).</span><span class="nx">done</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">d1</span><span class="p">,</span> <span class="nx">d2</span><span class="p">)</span> <span class="p">{</span> <span class="err">…</span> <span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>$.when()</code> に Defered でも Promise でもない値を渡した場合、解決済みの値として扱われます。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">$</span><span class="p">.</span><span class="nx">when</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="nx">promise</span><span class="p">).</span><span class="nx">done</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">d1</span><span class="p">,</span> <span class="nx">d2</span><span class="p">)</span> <span class="p">{</span> <span class="err">…</span> <span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>などとした場合、10は解決済みと見なされ、<code>promise</code>が解決済みになり次第、<code>d1</code> に 10 が渡されて callback が実行されます。</p>

<h2>$.ajax の戻り値は Promise</h2>

<p><code>$.ajax</code>, <code>$.get</code>, <code>$.post</code> など AJAX 関数群の戻り値 jqXHR は Promise と同じインタフェースを備えています。
すなわち <code>$.when</code> を使って、複数の AJAX 通信がすべて完了したら次に…をするといったコードが簡潔に書けます。</p>

<p>また <code>$.get</code> などはエラーコールバックを引数に取れませんが、戻り値は Promise ですので、これに <code>.fail()</code> を呼び出すことでエラーコールバックを登録することができます。
今まで使えない子だと思っていたのですが、僕が知らないだけでずっと前に使える子になってたんですね。</p>

<h2>まとめ</h2>

<p>なんだか長くなってしまった。まとめ。</p>

<ul>
<li>Deferred は３状態をもつ</li>
<li>解決済み、拒否済みになった時に実行するコールバックを登録できる</li>
<li>Promise は Deferred の機能制限版 (結果をもらう人向け)</li>
<li><code>$.when</code> で Deferred/Promise を組み合せられる</li>
<li><code>$.ajax</code>, <code>$.get</code>, etc. の戻り値は Promise</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Homebrew RMagick]]></title>
    <link href="http://tkawachi.github.io/blog/2013/01/05/homebrew-rmagick/"/>
    <updated>2013-01-05T14:38:00+09:00</updated>
    <id>http://tkawachi.github.io/blog/2013/01/05/homebrew-rmagick</id>
    <content type="html"><![CDATA[<p>Homebrew で ImageMagick をインストールして RVM 環境の ruby に rmagick gem を入れようとしたら意外に苦労したのでメモ。</p>

<!-- more -->


<p>最終的な手順</p>

<ol>
<li><code>brew update</code></li>
<li><code>brew install ghostscript imagemagick</code></li>
<li><code>ln -s /usr/local/lib/libMagickCore-Q16.dylib /usr/local/lib/libMagickCore.dylib</code></li>
<li><code>gem install rmagick</code></li>
<li><code>rm /usr/local/lib/libMagickCore.dylib</code></li>
</ol>


<p>ハマりポイント</p>

<ul>
<li>brew では <code>MagickCore-Q16</code> という名前でライブラリがインストールされる。
RMagick の <a href="https://github.com/rmagick/rmagick/blob/master/ext/RMagick/extconf.rb#L207">extconf.rb</a> では <code>MagickCore</code>, <code>Magick</code>, <code>Magick++</code> という
名前でライブラリの存在を確認しているため、ここで落ちる。
<code>-Q16</code> ってなんじゃ！

<ul>
<li>→ <code>/usr/local/lib/libMagickCore.dylib</code> に symlink しちゃう。
<code>MagickCore</code>, <code>Magick</code>, <code>Magick++</code> のうち一つだけあればチェックは通るので
<code>libMagickCore.dylib</code> だけで OK。
また gem のインストールが終わったら不要なので symlink 消しとく。</li>
</ul>
</li>
<li>rmagick gem のインストールが途中で止まる。ghostscript 入ってないと途中で止まるっぽい。。

<ul>
<li>→ brew で ghostscript も入れる。</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bootswatchのテーマをtwitter-bootstrap-railsで使う]]></title>
    <link href="http://tkawachi.github.io/blog/2013/01/04/use-bootswatch-with-rails/"/>
    <updated>2013-01-04T18:12:00+09:00</updated>
    <id>http://tkawachi.github.io/blog/2013/01/04/use-bootswatch-with-rails</id>
    <content type="html"><![CDATA[<p>美的センスに乏しい私のようなプログラマにとってTwitter bootstrapが便利なことは言うまでもありませんが、知っている人には一見して「あ、Bootstrapだ」とわかるサイトになってしまいます。
これ自体は別に悪いことはないと思うのですが、他のサイトと見分けの付かないサイトになってしまうのは良くないですよね。</p>

<p>そこでbootstrap用のテーマを入れよう、となるわけです。
テーマを入れることで色・フォントなどが変更されるので、bootstrap臭が軽減されます。</p>

<p>bootstrap theme などで検索すると有償・無償を含めテーマを取り扱っているサイトが見つかると思いますが、今回は <a href="http://bootswatch.com/">Bootswatch</a> を twitter-bootstrap-rails と共に使う方法をメモします。
bootstrap-sass, sass-twitter-bootstrap, less-rails-bootstrap の人は別の方法があると思います。</p>

<!-- more -->


<p>まず <a href="http://bootswatch.com/#gallery">Bootswatch の Gallery</a> から使いたいテーマを選びます。
<code>vendor/assets/stylesheets/bootswatch/</code> ディレクトリを作り、選んだテーマの Download ボタンから <code>variables.less</code> と <code>bootswatch.less</code> をダウンロードして、このディレクトリに保存します。</p>

<p><code>app/assets/stylesheets/</code> ではなく <code>vendor/assets/stylesheets/</code> 以下に <code>bootswatch</code> ディレクトリを作成して保存します。
なぜなら <code>app/assets/stylesheets/application.css.scss</code> にはデフォルトで <code>*= require_tree .</code> という行があり、<code>app/assets/stylesheets/</code> 以下にある <code>.less</code> ファイルはすべて require されてしまうからです。
<code>variables.less</code>, <code>bootswatch.less</code> は <code>@import</code> するものであって、require するとエラーになります。
それに <code>vendor</code> というのはサードパーティ製のアレヤコレヤを置くところなので、きっとこっちが正解でしょう。</p>

<p>あとは <code>bootstrap_and_overrides.css.less</code> で <code>@import “twitter/bootstrap/responsive”;</code> の行のあとに以下の２行を付け足します。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@import “bootswatch/variables.less”;
</span><span class='line'>@import “bootswatch/bootswatch.less”;</span></code></pre></td></tr></table></div></figure>


<p>これでいける(少なくとも僕は使えてる)と思うんですが、ダメだったら教えて下さい。</p>

<p>参考</p>

<ul>
<li><a href="http://bobonrails.com/post/29340795516/customizing-twitter-bootstrap-on-rails-3">Customizing Twitter Bootstrap On Rails 3</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Emacs Lisp Package Archive]]></title>
    <link href="http://tkawachi.github.io/blog/2012/12/31/emacs-lisp-package-archive/"/>
    <updated>2012-12-31T23:16:00+09:00</updated>
    <id>http://tkawachi.github.io/blog/2012/12/31/emacs-lisp-package-archive</id>
    <content type="html"><![CDATA[<p>Macでの日本語の文書を読み書きするテキストエディタを探していた。
Facebookでつぶやいていたらいろいろおすすめをいただいたのだが、これだ！！というものがなかった。
それで Emacs に戻ろうと思った。</p>

<p>ほぼ三年弱ぶりくらいに Emacs に戻ってきたのだが
<a href="http://emacswiki.org/emacs/ELPA">ELPA</a>
というパッケージマネージャがデフォルトで付いてきていて、ものすごく導入障壁が下がっていたのでメモしておく。</p>

<!-- more -->


<p>Mac OS X なので Emacs 自体は
<a href="http://emacsformacosx.com/">Emacs For Mac OS X</a>
からダウンロードした。
他のアプリと同じようにインストールできる。簡単。</p>

<p>おもむろに <code>M-x list-packages</code> とこんな画面が出てくる。</p>

<p><img src="http://tkawachi.github.io/images/20121231/list-packages.png" alt="M-x list-packages" /></p>

<p>青い下線があるところに移動して return を押すとこんなかんじでパッケージの説明が出てくる。</p>

<p><img src="http://tkawachi.github.io/images/20121231/show.png" alt="M-x list-packages" /></p>

<p>あとは <code>Install</code> と書かれているところに移動して return を押せばインストールが完了する。
簡単！</p>

<p>いくつか公開レポジトリがあるらしく以下のように設定しておけば複数のレポジトリからパッケージがインストールできる。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  (setq package-archives '(("gnu" . "http://elpa.gnu.org/packages/")
</span><span class='line'>                           ("marmalade" . "http://marmalade-repo.org/packages/")
</span><span class='line'>                           ("melpa" . "http://melpa.milkbox.net/packages/")))</span></code></pre></td></tr></table></div></figure>


<p>上の３つを入れた状態で <code>list-packages</code> すると現時点で 1000 程度のパッケージがリストされる。
これからもっと増えていくだろう。</p>

<p>perl でいうところの CPAN が Emacs にできたということだ。素晴らしい。</p>
]]></content>
  </entry>
  
</feed>
